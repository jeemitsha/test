(self.webpackChunktradingview = self.webpackChunktradingview || []).push([
    [64711], {
        981193: e => {
            e.exports = {
                container: "container-Mtq7m9Yl",
                "intent-default": "intent-default-Mtq7m9Yl",
                focused: "focused-Mtq7m9Yl",
                readonly: "readonly-Mtq7m9Yl",
                disabled: "disabled-Mtq7m9Yl",
                "with-highlight": "with-highlight-Mtq7m9Yl",
                grouped: "grouped-Mtq7m9Yl",
                "adjust-position": "adjust-position-Mtq7m9Yl",
                "first-row": "first-row-Mtq7m9Yl",
                "first-col": "first-col-Mtq7m9Yl",
                stretch: "stretch-Mtq7m9Yl",
                "font-size-medium": "font-size-medium-Mtq7m9Yl",
                "font-size-large": "font-size-large-Mtq7m9Yl",
                "no-corner-top-left": "no-corner-top-left-Mtq7m9Yl",
                "no-corner-top-right": "no-corner-top-right-Mtq7m9Yl",
                "no-corner-bottom-right": "no-corner-bottom-right-Mtq7m9Yl",
                "no-corner-bottom-left": "no-corner-bottom-left-Mtq7m9Yl",
                "size-small": "size-small-Mtq7m9Yl",
                "size-medium": "size-medium-Mtq7m9Yl",
                "size-large": "size-large-Mtq7m9Yl",
                "intent-success": "intent-success-Mtq7m9Yl",
                "intent-warning": "intent-warning-Mtq7m9Yl",
                "intent-danger": "intent-danger-Mtq7m9Yl",
                "intent-primary": "intent-primary-Mtq7m9Yl",
                "border-none": "border-none-Mtq7m9Yl",
                "border-thin": "border-thin-Mtq7m9Yl",
                "border-thick": "border-thick-Mtq7m9Yl",
                highlight: "highlight-Mtq7m9Yl",
                shown: "shown-Mtq7m9Yl"
            }
        },
        484684: e => {
            e.exports = {
                "inner-slot": "inner-slot-yJbunXPO",
                interactive: "interactive-yJbunXPO",
                icon: "icon-yJbunXPO",
                "inner-middle-slot": "inner-middle-slot-yJbunXPO",
                "before-slot": "before-slot-yJbunXPO",
                "after-slot": "after-slot-yJbunXPO"
            }
        },
        358089: e => {
            e.exports = {
                input: "input-oiYdY6I4",
                "with-start-slot": "with-start-slot-oiYdY6I4",
                "with-end-slot": "with-end-slot-oiYdY6I4"
            }
        },
        574292: e => {
            e.exports = {
                scrollWrap: "scrollWrap-Lt5uPNKI"
            }
        },
        82461: e => {
            e.exports = {
                wrap: "wrap-cbCWDq_M",
                "wrap--horizontal": "wrap--horizontal-cbCWDq_M",
                bar: "bar-cbCWDq_M",
                barInner: "barInner-cbCWDq_M",
                "barInner--horizontal": "barInner--horizontal-cbCWDq_M",
                "bar--horizontal": "bar--horizontal-cbCWDq_M"
            }
        },
        820577: e => {
            e.exports = {
                dropTargetInside: "dropTargetInside-fd_GivvG",
                dropTarget: "dropTarget-fd_GivvG",
                before: "before-fd_GivvG",
                after: "after-fd_GivvG"
            }
        },
        603950: e => {
            e.exports = {
                wrap: "wrap-G4AKrzja",
                selected: "selected-G4AKrzja",
                childOfSelected: "childOfSelected-G4AKrzja",
                disabled: "disabled-G4AKrzja",
                expandHandle: "expandHandle-G4AKrzja",
                expanded: "expanded-G4AKrzja"
            }
        },
        643380: e => {
            e.exports = {
                separator: "separator-zol_jClG",
                tree: "tree-zol_jClG",
                overlayScrollWrap: "overlayScrollWrap-zol_jClG",
                listContainer: "listContainer-zol_jClG"
            }
        },
        734393: e => {
            e.exports = {
                button: "button-W4RYPlVi",
                disabled: "disabled-W4RYPlVi"
            }
        },
        409790: e => {
            e.exports = {
                menuWrap: "menuWrap-biWYdsXC",
                isMeasuring: "isMeasuring-biWYdsXC",
                scrollWrap: "scrollWrap-biWYdsXC",
                momentumBased: "momentumBased-biWYdsXC",
                menuBox: "menuBox-biWYdsXC",
                isHidden: "isHidden-biWYdsXC"
            }
        },
        655498: e => {
            e.exports = {
                "tablet-small-breakpoint": "screen and (max-width: 430px)",
                item: "item-RhC5uhZw",
                hovered: "hovered-RhC5uhZw",
                isDisabled: "isDisabled-RhC5uhZw",
                isActive: "isActive-RhC5uhZw",
                shortcut: "shortcut-RhC5uhZw",
                toolbox: "toolbox-RhC5uhZw",
                withIcon: "withIcon-RhC5uhZw",
                icon: "icon-RhC5uhZw",
                labelRow: "labelRow-RhC5uhZw",
                label: "label-RhC5uhZw",
                showOnHover: "showOnHover-RhC5uhZw"
            }
        },
        452395: (e, t, n) => {
            "use strict";
            n.d(t, {
                ControlSkeleton: () => v,
                InputClasses: () => m
            });
            var o = n(50959),
                r = n(497754),
                s = n(650151),
                i = n(662929),
                l = n(8626),
                c = n(301792),
                a = n(307754);
            var d = n(981193),
                u = n.n(d);

            function h(e) {
                let t = "";
                return 0 !== e && (1 & e && (t = r(t, u()["no-corner-top-left"])), 2 & e && (t = r(t, u()["no-corner-top-right"])), 4 & e && (t = r(t, u()["no-corner-bottom-right"])), 8 & e && (t = r(t, u()["no-corner-bottom-left"]))), t
            }

            function p(e, t, n, o) {
                const {
                    removeRoundBorder: s,
                    className: i,
                    intent: l = "default",
                    borderStyle: c = "thin",
                    size: d,
                    highlight: p,
                    disabled: f,
                    readonly: m,
                    stretch: E,
                    noReadonlyStyles: g,
                    isFocused: v
                } = e, S = h(null != s ? s : (0, a.getGroupCellRemoveRoundBorders)(n));
                return r(u().container, u()[`intent-${l}`], u()[`border-${c}`], d && u()[`size-${d}`], S, p && u()["with-highlight"], f && u().disabled, m && !g && u().readonly, v && u().focused, E && u().stretch, t && u().grouped, !o && u()["adjust-position"], n.isTop && u()["first-row"], n.isLeft && u()["first-col"], i)
            }

            function f(e, t) {
                const {
                    highlight: n,
                    highlightRemoveRoundBorder: o
                } = e;
                if (!n) return u().highlight;
                const s = h(null != o ? o : (0, a.getGroupCellRemoveRoundBorders)(t));
                return r(u().highlight, u().shown, s)
            }
            const m = {
                    FontSizeMedium: (0, s.ensureDefined)(u()["font-size-medium"]),
                    FontSizeLarge: (0, s.ensureDefined)(u()["font-size-large"])
                },
                E = {
                    passive: !1
                };

            function g(e, t) {
                const {
                    style: n,
                    id: r,
                    role: s,
                    onFocus: a,
                    onBlur: d,
                    onMouseOver: u,
                    onMouseOut: h,
                    onMouseDown: m,
                    onMouseUp: g,
                    onKeyDown: v,
                    onClick: S,
                    tabIndex: T,
                    startSlot: D,
                    middleSlot: _,
                    endSlot: C,
                    onWheel: y,
                    onWheelNoPassive: b = null
                } = e, {
                    isGrouped: N,
                    cellState: M,
                    disablePositionAdjustment: I = !1
                } = (0, o.useContext)(c.ControlGroupContext), O = function(e, t = null, n) {
                    const r = (0, o.useRef)(null),
                        s = (0, o.useRef)(null),
                        i = (0, o.useCallback)((() => {
                            if (null === r.current || null === s.current) return;
                            const [e, t, n] = s.current;
                            null !== t && r.current.addEventListener(e, t, n)
                        }), []),
                        l = (0, o.useCallback)((() => {
                            if (null === r.current || null === s.current) return;
                            const [e, t, n] = s.current;
                            null !== t && r.current.removeEventListener(e, t, n)
                        }), []),
                        c = (0, o.useCallback)((e => {
                            l(), r.current = e, i()
                        }), []);
                    return (0, o.useEffect)((() => (s.current = [e, t, n], i(), l)), [e, t, n]), c
                }("wheel", b, E);
                return o.createElement("span", {
                    style: n,
                    id: r,
                    role: s,
                    className: p(e, N, M, I),
                    tabIndex: T,
                    ref: (0, i.useMergedRefs)([t, O]),
                    onFocus: a,
                    onBlur: d,
                    onMouseOver: u,
                    onMouseOut: h,
                    onMouseDown: m,
                    onMouseUp: g,
                    onKeyDown: v,
                    onClick: S,
                    onWheel: y,
                    ...(0, l.filterDataProps)(e),
                    ...(0, l.filterAriaProps)(e)
                }, D, _, C, o.createElement("span", {
                    className: f(e, M)
                }))
            }
            g.displayName = "ControlSkeleton";
            const v = o.forwardRef(g)
        },
        514420: (e, t, n) => {
            "use strict";
            n.d(t, {
                BeforeSlot: () => l,
                StartSlot: () => c,
                MiddleSlot: () => a,
                EndSlot: () => d,
                AfterSlot: () => u
            });
            var o = n(50959),
                r = n(497754),
                s = n(484684),
                i = n.n(s);

            function l(e) {
                const {
                    className: t,
                    children: n
                } = e;
                return o.createElement("span", {
                    className: r(i()["before-slot"], t)
                }, n)
            }

            function c(e) {
                const {
                    className: t,
                    interactive: n = !0,
                    icon: s = !1,
                    children: l
                } = e;
                return o.createElement("span", {
                    className: r(i()["inner-slot"], n && i().interactive, s && i().icon, t)
                }, l)
            }

            function a(e) {
                const {
                    className: t,
                    children: n
                } = e;
                return o.createElement("span", {
                    className: r(i()["inner-slot"], i()["inner-middle-slot"], t)
                }, n)
            }

            function d(e) {
                const {
                    className: t,
                    interactive: n = !0,
                    icon: s = !1,
                    children: l
                } = e;
                return o.createElement("span", {
                    className: r(i()["inner-slot"], n && i().interactive, s && i().icon, t)
                }, l)
            }

            function u(e) {
                const {
                    className: t,
                    children: n
                } = e;
                return o.createElement("span", {
                    className: r(i()["after-slot"], t)
                }, n)
            }
        },
        142135: (e, t, n) => {
            "use strict";
            n.d(t, {
                Input: () => o.Input,
                InputControl: () => o.InputControl
            });
            var o = n(314551)
        },
        314551: (e, t, n) => {
            "use strict";
            n.d(t, {
                Input: () => g,
                InputControl: () => v
            });
            var o = n(50959),
                r = n(497754),
                s = n(8626),
                i = n(763341),
                l = n(151057),
                c = n(662929),
                a = n(207357),
                d = n(405964),
                u = n(633750),
                h = n(452395),
                p = n(514420),
                f = n(358089),
                m = n.n(f);

            function E(e) {
                return !(0, s.isAriaAttribute)(e) && !(0, s.isDataAttribute)(e)
            }

            function g(e) {
                const {
                    id: t,
                    title: n,
                    role: i,
                    tabIndex: l,
                    placeholder: c,
                    name: a,
                    type: d,
                    value: u,
                    defaultValue: f,
                    draggable: g,
                    autoComplete: v,
                    autoFocus: S,
                    maxLength: T,
                    min: D,
                    max: _,
                    step: C,
                    pattern: y,
                    inputMode: b,
                    onSelect: N,
                    onFocus: M,
                    onBlur: I,
                    onKeyDown: O,
                    onKeyUp: R,
                    onKeyPress: w,
                    onChange: x,
                    onDragStart: L,
                    size: P = "medium",
                    className: k,
                    inputClassName: A,
                    disabled: F,
                    readonly: W,
                    containerTabIndex: z,
                    startSlot: B,
                    endSlot: H,
                    reference: U,
                    containerReference: Y,
                    onContainerFocus: G,
                    ...q
                } = e, V = (0, s.filterProps)(q, E), K = { ...(0, s.filterAriaProps)(q),
                    ...(0, s.filterDataProps)(q),
                    id: t,
                    title: n,
                    role: i,
                    tabIndex: l,
                    placeholder: c,
                    name: a,
                    type: d,
                    value: u,
                    defaultValue: f,
                    draggable: g,
                    autoComplete: v,
                    autoFocus: S,
                    maxLength: T,
                    min: D,
                    max: _,
                    step: C,
                    pattern: y,
                    inputMode: b,
                    onSelect: N,
                    onFocus: M,
                    onBlur: I,
                    onKeyDown: O,
                    onKeyUp: R,
                    onKeyPress: w,
                    onChange: x,
                    onDragStart: L
                };
                return o.createElement(h.ControlSkeleton, { ...V,
                    disabled: F,
                    readonly: W,
                    tabIndex: z,
                    className: r(m().container, k),
                    size: P,
                    ref: Y,
                    onFocus: G,
                    startSlot: B,
                    middleSlot: o.createElement(p.MiddleSlot, null, o.createElement("input", { ...K,
                        className: r(m().input, A, B && m()["with-start-slot"], H && m()["with-end-slot"]),
                        disabled: F,
                        readOnly: W,
                        ref: U
                    })),
                    endSlot: H
                })
            }

            function v(e) {
                e = (0, a.useControl)(e);
                const {
                    disabled: t,
                    autoSelectOnFocus: n,
                    tabIndex: r = 0,
                    onFocus: s,
                    onBlur: h,
                    reference: p,
                    containerReference: f = null
                } = e, m = (0, o.useRef)(null), E = (0, o.useRef)(null), [v, S] = (0, d.useFocus)(), T = t ? void 0 : v ? -1 : r, D = t ? void 0 : v ? r : -1, {
                    isMouseDown: _,
                    handleMouseDown: C,
                    handleMouseUp: y
                } = (0, u.useIsMouseDown)(), b = (0, i.createSafeMulticastEventHandler)(S.onFocus, (function(e) {
                    n && !_.current && (0, l.selectAllContent)(e.currentTarget)
                }), s), N = (0, i.createSafeMulticastEventHandler)(S.onBlur, h), M = (0, o.useCallback)((e => {
                    m.current = e, p && ("function" == typeof p && p(e), "object" == typeof p && (p.current = e))
                }), [m, p]);
                return o.createElement(g, { ...e,
                    isFocused: v,
                    containerTabIndex: T,
                    tabIndex: D,
                    onContainerFocus: function(e) {
                        E.current === e.target && null !== m.current && m.current.focus()
                    },
                    onFocus: b,
                    onBlur: N,
                    reference: M,
                    containerReference: (0, c.useMergedRefs)([E, f]),
                    onMouseDown: C,
                    onMouseUp: y
                })
            }
        },
        207357: (e, t, n) => {
            "use strict";
            n.d(t, {
                useControl: () => s
            });
            var o = n(763341),
                r = n(405964);

            function s(e) {
                const {
                    onFocus: t,
                    onBlur: n,
                    intent: s,
                    highlight: i,
                    disabled: l
                } = e, [c, a] = (0, r.useFocus)(void 0, l), d = (0, o.createSafeMulticastEventHandler)(l ? void 0 : a.onFocus, t), u = (0, o.createSafeMulticastEventHandler)(l ? void 0 : a.onBlur, n);
                return { ...e,
                    intent: s || (c ? "primary" : "default"),
                    highlight: null != i ? i : c,
                    onFocus: d,
                    onBlur: u
                }
            }
        },
        405964: (e, t, n) => {
            "use strict";
            n.d(t, {
                useFocus: () => r
            });
            var o = n(50959);

            function r(e, t) {
                const [n, r] = (0, o.useState)(!1);
                (0, o.useEffect)((() => {
                    t && n && r(!1)
                }), [t, n]);
                const s = {
                    onFocus: (0, o.useCallback)((function(t) {
                        void 0 !== e && e.current !== t.target || r(!0)
                    }), [e]),
                    onBlur: (0, o.useCallback)((function(t) {
                        void 0 !== e && e.current !== t.target || r(!1)
                    }), [e])
                };
                return [n, s]
            }
        },
        633750: (e, t, n) => {
            "use strict";
            n.d(t, {
                useIsMouseDown: () => r
            });
            var o = n(50959);

            function r() {
                const e = (0, o.useRef)(!1),
                    t = (0, o.useCallback)((() => {
                        e.current = !0
                    }), [e]),
                    n = (0, o.useCallback)((() => {
                        e.current = !1
                    }), [e]);
                return {
                    isMouseDown: e,
                    handleMouseDown: t,
                    handleMouseUp: n
                }
            }
        },
        662929: (e, t, n) => {
            "use strict";
            n.d(t, {
                useMergedRefs: () => s
            });
            var o = n(50959),
                r = n(551080);

            function s(e) {
                return (0, o.useCallback)((0, r.mergeRefs)(e), e)
            }
        },
        151057: (e, t, n) => {
            "use strict";

            function o(e) {
                null !== e && e.setSelectionRange(0, e.value.length)
            }
            n.d(t, {
                selectAllContent: () => o
            })
        },
        763341: (e, t, n) => {
            "use strict";

            function o(...e) {
                return t => {
                    for (const n of e) void 0 !== n && n(t)
                }
            }
            n.d(t, {
                createSafeMulticastEventHandler: () => o
            })
        },
        531327: (e, t, n) => {
            "use strict";

            function o(e) {
                return r() ? 0 : s() ? 46 : Math.min(Math.max(e, 46), 450)
            }
            n.d(t, {
                getWidgetBarPadding: () => o,
                isWidgetBarFullscreen: () => r
            });
            const r = () => !window.matchMedia("screen and (min-width: 768px)").matches,
                s = () => !window.matchMedia("screen and (min-width: 1280px)").matches
        },
        314308: (e, t, n) => {
            "use strict";

            function o(e, t, n, o, r) {
                function s(r) {
                    if (e > r.timeStamp) return;
                    const s = r.target;
                    void 0 !== n && null !== t && null !== s && s.ownerDocument === o && (t.contains(s) || n(r))
                }
                return r.click && o.addEventListener("click", s, !1), r.mouseDown && o.addEventListener("mousedown", s, !1), r.touchEnd && o.addEventListener("touchend", s, !1), r.touchStart && o.addEventListener("touchstart", s, !1), () => {
                    o.removeEventListener("click", s, !1), o.removeEventListener("mousedown", s, !1), o.removeEventListener("touchend", s, !1), o.removeEventListener("touchstart", s, !1)
                }
            }
            n.d(t, {
                addOutsideEventListener: () => o
            })
        },
        575658: (e, t, n) => {
            "use strict";
            n.d(t, {
                setFixedBodyState: () => l
            });
            var o = n(76107),
                r = n(531327);
            let s = 0,
                i = !1;

            function l(e) {
                const {
                    body: t
                } = document, n = t.querySelector(".widgetbar-wrap");
                if (e && 1 == ++s) {
                    const e = (0, o.getCSSProperty)(t, "overflow"),
                        r = (0, o.getCSSPropertyNumericValue)(t, "padding-right");
                    "hidden" !== e.toLowerCase() && t.scrollHeight > t.offsetHeight && ((0, o.setStyle)(n, "right", `${(0,o.getScrollbarWidth)()}px`), t.style.paddingRight = `${r+(0,o.getScrollbarWidth)()}px`, i = !0), t.classList.add("i-no-scroll")
                } else if (!e && s > 0 && 0 == --s && (t.classList.remove("i-no-scroll"), i)) {
                    (0, o.setStyle)(n, "right", "0px");
                    let e = 0;
                    e = n ? (0, r.getWidgetBarPadding)((0, o.getContentWidth)(n)) : 0, t.scrollHeight <= t.clientHeight && (e -= (0, o.getScrollbarWidth)()), t.style.paddingRight = (e < 0 ? 0 : e) + "px", i = !1
                }
            }
        },
        451860: (e, t, n) => {
            "use strict";
            n.d(t, {
                OverlayScrollContainer: () => p
            });
            var o = n(50959),
                r = n(497754),
                s = n.n(r),
                i = n(650151),
                l = n(43329),
                c = n(768038);
            const a = n(82461);

            function d(e) {
                const {
                    size: t,
                    scrollSize: n,
                    clientSize: r,
                    scrollProgress: d,
                    onScrollProgressChange: u,
                    horizontal: h,
                    theme: p = a,
                    onDragStart: f,
                    onDragEnd: m,
                    minBarSize: E = 40
                } = e, g = (0, o.useRef)(null), v = (0,
                    o.useRef)(null), [S, T] = (0, o.useState)(!1), D = (0, o.useRef)(0);
                (0, o.useEffect)((() => {
                    const e = (0, i.ensureNotNull)(g.current).ownerDocument;
                    return S ? (f && f(), e && (e.addEventListener("mousemove", M), e.addEventListener("mouseup", I))) : m && m(), () => {
                        e && (e.removeEventListener("mousemove", M), e.removeEventListener("mouseup", I))
                    }
                }), [S]);
                const _ = t / n || 0,
                    C = r * _ || 0,
                    y = Math.max(C, E),
                    b = (t - y) / (t - C),
                    N = function(e) {
                        if ((0, c.isRtl)() && h) return e - n + r;
                        return e
                    }((0, l.clamp)(d, 0, n - t));
                return o.createElement("div", {
                    ref: g,
                    className: s()(p.wrap, h && p["wrap--horizontal"]),
                    style: {
                        [h ? "width" : "height"]: t
                    },
                    onMouseDown: function(e) {
                        if (e.isDefaultPrevented()) return;
                        e.preventDefault();
                        const o = (0, i.ensureNotNull)(v.current).getBoundingClientRect();
                        D.current = (h ? o.width : o.height) / 2;
                        const r = n - t;
                        let s = O(e.nativeEvent, (0, i.ensureNotNull)(g.current)) - D.current;
                        s < 0 ? (s = 0, D.current = O(e.nativeEvent, (0, i.ensureNotNull)(g.current))) : s > r * _ * b && (s = r * _ * b, D.current = O(e.nativeEvent, (0, i.ensureNotNull)(g.current)) - s);
                        u(s / _ / b), T(!0)
                    }
                }, o.createElement("div", {
                    ref: v,
                    className: s()(p.bar, h && p["bar--horizontal"]),
                    style: {
                        [h ? "minWidth" : "minHeight"]: E,
                        [h ? "width" : "height"]: y,
                        transform: `translate${h?"X":"Y"}(${N*_*b||0}px)`
                    },
                    onMouseDown: function(e) {
                        e.preventDefault(), D.current = O(e.nativeEvent, (0, i.ensureNotNull)(v.current)), T(!0)
                    }
                }, o.createElement("div", {
                    className: s()(p.barInner, h && p["barInner--horizontal"])
                })));

                function M(e) {
                    const t = O(e, (0, i.ensureNotNull)(g.current)) - D.current;
                    u(t / _ / b)
                }

                function I(e) {
                    T(!1)
                }

                function O(e, t) {
                    const n = t.getBoundingClientRect();
                    return h ? e.clientX - n.left : e.clientY - n.top
                }
            }
            var u = n(962624),
                h = n(574292);

            function p(e) {
                const {
                    reference: t,
                    className: n,
                    containerHeight: s = 0,
                    containerWidth: i = 0,
                    contentHeight: l = 0,
                    contentWidth: c = 0,
                    scrollPosTop: a = 0,
                    scrollPosLeft: p = 0,
                    onVerticalChange: f,
                    onHorizontalChange: m,
                    visible: E
                } = e, [g, v] = (0, u.useHover)(), [S, T] = (0, o.useState)(!1), D = s < l, _ = i < c, C = D && _ ? 8 : 0;
                return o.createElement("div", { ...v,
                    ref: t,
                    className: r(n, h.scrollWrap),
                    style: {
                        visibility: E || g || S ? "visible" : "hidden"
                    }
                }, D && o.createElement(d, {
                    size: s - C,
                    scrollSize: l - C,
                    clientSize: s - C,
                    scrollProgress: a,
                    onScrollProgressChange: function(e) {
                        f && f(e)
                    },
                    onDragStart: y,
                    onDragEnd: b
                }), _ && o.createElement(d, {
                    size: i - C,
                    scrollSize: c - C,
                    clientSize: i - C,
                    scrollProgress: p,
                    onScrollProgressChange: function(e) {
                        m && m(e)
                    },
                    onDragStart: y,
                    onDragEnd: b,
                    horizontal: !0
                }));

                function y() {
                    T(!0)
                }

                function b() {
                    T(!1)
                }
            }
        },
        960466: (e, t, n) => {
            "use strict";
            n.d(t, {
                SizeContext: () => o
            });
            const o = n(50959).createContext({
                size: 0,
                smallSizeTreeNodeAction: 1
            })
        },
        126425: (e, t, n) => {
            "use strict";
            n.d(t, {
                resetTree: () => r,
                syncNodes: () => s,
                setNodes: () => i,
                selectPrevious: () => l,
                selectNext: () => c,
                multiSelectPrevious: () => a,
                multiSelectNext: () => d,
                processDropTarget: () => u,
                dropSelection: () => h,
                updateDropTarget: () => p,
                hideDropTarget: () => f,
                setSelectedIds: () => m,
                moveNodes: () => E,
                startMultiSelect: () => g,
                stopMultiSelect: () => v,
                setFocusedNode: () => S,
                scrollToId: () => T,
                setIsSelected: () => D,
                setIsExpanded: () => _,
                setDisabledNodes: () => C,
                endDrag: () => y
            });
            var o = n(570225);
            const r = () => ({
                    type: o.RESET_TREE
                }),
                s = e => ({
                    type: o.SYNC_NODES,
                    nodes: e
                }),
                i = e => ({
                    type: o.SET_NODES,
                    nodes: e
                }),
                l = () => ({
                    type: o.SELECT_PREVIOUS
                }),
                c = () => ({
                    type: o.SELECT_NEXT
                }),
                a = () => ({
                    type: o.MULTI_SELECT_PREVIOUS
                }),
                d = () => ({
                    type: o.MULTI_SELECT_NEXT
                }),
                u = (e, t, n, r, s) => ({
                    type: o.PROCESS_DROP_TARGET,
                    dropTarget: e,
                    dropType: t,
                    isHoveredLeft: n,
                    boundBox: r,
                    isLastChild: s
                }),
                h = () => ({
                    type: o.DROP_SELECTION
                }),
                p = (e, t, n) => ({
                    type: o.UPDATE_DROP_TARGET,
                    node: e,
                    dropType: t,
                    boundBox: n
                }),
                f = () => ({
                    type: o.HIDE_DROP_TARGET
                }),
                m = e => ({
                    type: o.SET_SELECTED_IDS,
                    ids: e
                }),
                E = (e, t, n) => ({
                    type: o.MOVE_NODES,
                    ids: e,
                    targetId: t,
                    dropType: n
                }),
                g = () => ({
                    type: o.START_MULTI_SELECT
                }),
                v = () => ({
                    type: o.STOP_MULTI_SELECT
                }),
                S = e => ({
                    type: o.SET_FOCUSED_NODE,
                    nodeId: e
                }),
                T = e => ({
                    type: o.SCROLL_TO_ID,
                    nodeId: e
                }),
                D = (e, t, n = 0) => ({
                    type: o.SET_IS_SELECTED,
                    nodeId: e,
                    isSelected: t,
                    mode: n
                }),
                _ = (e, t) => ({
                    type: o.SET_IS_EXPANDED,
                    nodeId: e,
                    isExpanded: t
                }),
                C = e => ({
                    type: o.SET_DISABLED_NODES,
                    ids: e
                }),
                y = () => ({
                    type: o.END_DRAG
                })
        },
        570225: (e, t, n) => {
            "use strict";
            n.d(t, {
                SET_NODES: () => r,
                SYNC_NODES: () => s,
                UPDATE_NODE: () => i,
                UPDATE_NODES: () => l,
                RESET_TREE: () => c,
                SET_SELECTED_IDS: () => a,
                DROP_SELECTION: () => d,
                SELECT_PREVIOUS: () => u,
                SELECT_NEXT: () => h,
                MULTI_SELECT_PREVIOUS: () => p,
                MULTI_SELECT_NEXT: () => f,
                PROCESS_DROP_TARGET: () => m,
                UPDATE_DROP_TARGET: () => E,
                HIDE_DROP_TARGET: () => g,
                START_MULTI_SELECT: () => v,
                STOP_MULTI_SELECT: () => S,
                SET_FOCUSED_NODE: () => T,
                SCROLL_TO_ID: () => D,
                SET_IS_SELECTED: () => _,
                SET_IS_EXPANDED: () => C,
                SET_DISABLED_NODES: () => y,
                MOVE_NODES: () => b,
                END_DRAG: () => N
            });
            const o = (0, n(66889).createActionTypeFactory)("OBJECT_TREE"),
                r = o("SET_NODES"),
                s = o("SYNC_NODES"),
                i = o("UPDATE_NODE"),
                l = o("UPDATE_NODES"),
                c = o("RESET_TREE"),
                a = o("SET_SELECTED_IDS"),
                d = o("DROP_SELECTION"),
                u = o("SELECT_PREVIOUS"),
                h = o("SELECT_NEXT"),
                p = o("MULTI_SELECT_PREVIOUS"),
                f = o("MULTI_SELECT_NEXT"),
                m = o("PROCESS_DROP_TARGET"),
                E = o("UPDATE_DROP_TARGET"),
                g = o("HIDE_DROP_TARGET"),
                v = o("START_MULTI_SELECT"),
                S = o("STOP_MULTI_SELECT"),
                T = (o("REMOVE_NODE"), o("SET_FOCUSED_NODE")),
                D = o("SCROLL_TO_ID"),
                _ = o("SET_IS_SELECTED"),
                C = o("SET_IS_EXPANDED"),
                y = o("SET_DISABLED_NODES"),
                b = o("MOVE_NODES"),
                N = (o("START_DRAG"), o("END_DRAG"))
        },
        557314: (e, t, n) => {
            "use strict";
            n.d(t, {
                nodesSelector: () => s,
                dropTargetSelector: () => l,
                scrollToIdSelector: () => a,
                nodeSelector: () => u,
                isSelectedSelector: () => h,
                isExpandedSelector: () => p,
                isDisabledSelector: () => f,
                nodeIdsSelector: () => m,
                selectedIdsSelector: () => E,
                lastFocusedNodeIdSelector: () => g,
                isMultiSelectingSelector: () => v,
                selectedNodesSelector: () => S,
                orderedNodesSelector: () => D,
                renderListSelector: () => C,
                renderDragListSelector: () => y
            });
            var o = n(377145),
                r = n(650151);
            const s = e => e.nodes,
                i = e => e.selection,
                l = e => e.dropTarget,
                c = e => e.expanded,
                a = e => e.scrollToId,
                d = (e, t) => t,
                u = (0, o.createSelector)([s, d], ((e, t) => e[t])),
                h = (0, o.createSelector)([i, d], ((e, t) => e.ids.includes(t))),
                p = (0, o.createSelector)([c, d], ((e, t) => e.includes(t))),
                f = (0, o.createSelector)([e => e.disabled, i, d], ((e, t, n) => !t.ids.includes(n) && e.includes(n))),
                m = (0, o.createSelector)(s, (e => Object.keys(e))),
                E = (0, o.createSelector)(i, (({
                    ids: e
                }) => e)),
                g = (0, o.createSelector)(i, (({
                    lastFocusedNodeId: e
                }) => e)),
                v = (0, o.createSelector)(i, (({
                    isMultiSelecting: e
                }) => e)),
                S = (0, o.createSelector)([s, E], ((e, t) => t.map((t => e[t])))),
                T = (0, o.createSelector)(s, (e => Object.values(e).filter((e => 0 === e.level)))),
                D = (0,
                    o.createSelector)([s, T], ((e, t) => t.reduce(((t, n) => [...t, ..._(e, (0, r.ensureDefined)(n))]), [])));

            function _(e, t) {
                const n = [];
                for (const o of t.children) n.push(e[o]), n.push(..._(e, e[o]));
                return n
            }
            const C = (0, o.createSelector)([s, T, c], ((e, t, n) => {
                    const o = new Set(n);
                    return t.reduce(((t, n) => [...t, ...b(e, (0, r.ensureDefined)(n), o)]), [])
                })),
                y = (0, o.createSelector)([s, E, c], ((e, t, n) => {
                    const o = new Set(n);
                    return [{
                        id: "drag-list",
                        level: -1,
                        children: t
                    }].reduce(((t, n) => [...t, ...b(e, (0, r.ensureDefined)(n), o)]), [])
                }));

            function b(e, t, n) {
                const o = [];
                for (const r of t.children) {
                    const t = e[r];
                    void 0 !== t && (o.push(t), n.has(r) && o.push(...b(e, t, n)))
                }
                return o
            }
        },
        28473: (e, t, n) => {
            "use strict";
            n.d(t, {
                logger: () => s,
                getInsertIndex: () => i
            });
            var o = n(272001),
                r = n(650151);
            const s = (0, o.getLogger)("Platform.GUI.ObjectTree.CallApi"),
                i = (e, t, n) => {
                    switch (n) {
                        case "before":
                            return e.indexOf((0, r.ensureDefined)(t));
                        case "inside":
                            return e.length;
                        case "after":
                            return e.indexOf((0, r.ensureDefined)(t)) + 1;
                        default:
                            return 0
                    }
                }
        },
        478293: (e, t, n) => {
            "use strict";
            n.d(t, {
                Tree: () => Oe
            });
            var o = n(50959),
                r = n(254773),
                s = n(386942),
                i = n(10170),
                l = n(207809),
                c = n(23642),
                a = n(336349),
                d = n(570225),
                u = n(126425),
                h = n(557314);

            function* p(e) {
                const {
                    selectedIds: t,
                    nodes: n
                } = yield(0, a.call)(e), o = {};
                for (let e = 0; e < n.length; ++e) {
                    const t = n[e];
                    o[t.id] = t
                }
                yield(0, a.put)((0, u.setNodes)(o)), yield(0, a.put)((0, u.setSelectedIds)(t));
                !(0, h.lastFocusedNodeIdSelector)(yield(0, a.select)()) && t.length > 0 && (yield(0, a.put)((0, u.setFocusedNode)(t[0])), yield(0, a.put)((0, u.scrollToId)(t[0])))
            }
            var f = n(650151);

            function* m(e) {
                for (;;) {
                    if ((yield(0, a.take)([d.START_MULTI_SELECT, d.STOP_MULTI_SELECT])).type === d.START_MULTI_SELECT) {
                        const t = (0, h.nodeIdsSelector)(yield(0, a.select)()).filter((t => !e(t)));
                        yield(0, a.put)((0, u.setDisabledNodes)(t))
                    } else yield(0, a.put)((0, u.setDisabledNodes)([]))
                }
            }

            function* E() {
                for (;;) {
                    const {
                        type: e
                    } = yield(0, a.take)([d.MULTI_SELECT_NEXT, d.MULTI_SELECT_PREVIOUS]), t = yield(0, a.select)(), n = (0, h.orderedNodesSelector)(t), o = n.length, r = (0, h.lastFocusedNodeIdSelector)(t), s = [...(0, h.selectedIdsSelector)(t)], i = 1 === s.length && s[0] !== r, l = n.findIndex((e => e.id === (i ? s[0] : r)));
                    if (e === d.MULTI_SELECT_PREVIOUS && 0 === l || e === d.MULTI_SELECT_NEXT && l === o - 1) continue;
                    const c = C(t, e === d.MULTI_SELECT_NEXT ? "next" : "previous", n, l),
                        {
                            id: p
                        } = c;
                    s.includes(p) && r ? (yield(0, a.put)((0, u.setIsSelected)(r, !1, 1)), yield(0, a.put)((0, u.setFocusedNode)(p))) : yield(0, a.put)((0, u.setIsSelected)(p, !0, 1)), yield(0, a.put)((0, u.scrollToId)(p))
                }
            }

            function* g(e, t) {
                for (;;) {
                    const {
                        type: n
                    } = yield(0, a.take)([d.SELECT_NEXT, d.SELECT_PREVIOUS]), o = yield(0, a.select)(), r = (0, h.orderedNodesSelector)(o), s = (0, h.selectedNodesSelector)(o), i = (0, h.lastFocusedNodeIdSelector)(o);
                    if (1 === s.length && s[0].id !== i && !i) {
                        if (n === d.SELECT_NEXT) {
                            yield(0, a.put)((0, u.setFocusedNode)(s[0].id));
                            continue
                        }
                        if (n === d.SELECT_PREVIOUS) {
                            const e = r.findIndex((e => e.id === s[0].id)),
                                t = C(o, "previous", r, e);
                            yield(0, a.put)((0, u.setFocusedNode)(t.id));
                            continue
                        }
                    }
                    const l = r.findIndex((e => e.id === i)),
                        c = n === d.SELECT_NEXT ? "next" : "previous",
                        p = C(o, c, r, l),
                        {
                            id: f
                        } = p;
                    e ? e([f], c) : yield(0, a.put)((0, u.setSelectedIds)([f])), t && t(f), yield(0, a.put)((0, u.setFocusedNode)(f))
                }
            }

            function* v(e, t = (() => !0)) {
                for (;;) {
                    const {
                        mode: n,
                        nodeId: o,
                        isSelected: r
                    } = yield(0, a.take)(d.SET_IS_SELECTED);
                    let s = [...(0, h.selectedIdsSelector)(yield(0, a.select)())];
                    const i = (0, h.orderedNodesSelector)(yield(0, a.select)());
                    if (1 === n) r ? s.push(o) : s.splice(s.indexOf(o), 1);
                    else if (2 === n && s.length > 0) {
                        const e = (0, h.lastFocusedNodeIdSelector)(yield(0, a.select)());
                        let n = i.findIndex((t => t.id === e)); - 1 === n && (n = i.reduce(((e, t, n) => s.includes(t.id) ? n : e), -1));
                        const r = i.findIndex((e => e.id === o));
                        if (n !== r)
                            for (let e = Math.min(n, r); e <= Math.max(n, r); e++) {
                                const n = i[e].id;
                                !s.includes(n) && t(n) && s.push(n)
                            }
                    } else s = o ? [o] : [];
                    const l = new Set(s);
                    s = i.reduce(((e, t) => (l.has(t.id) && e.push(t.id), e)), []), e ? e(s) : yield(0, a.put)((0, u.setSelectedIds)(s)), yield(0, a.put)((0, u.setFocusedNode)(o))
                }
            }

            function* S(e = (() => !0), t) {
                const {
                    dropTarget: n,
                    dropType: o,
                    isHoveredLeft: r,
                    boundBox: s,
                    isLastChild: i
                } = t, l = (0, h.dropTargetSelector)(yield(0, a.select)()), c = (0, h.nodeSelector)(yield(0, a.select)(), (0, f.ensureDefined)(n.parentId)), d = i && "after" === o, p = (0, h.selectedNodesSelector)(yield(0, a.select)()), m = !d || !r && e(p, n, o) ? n : c, E = l.node && l.node.id !== m.id || l.dropType !== o;
                p.map((e => e.id)).includes(m.id) ? yield(0, a.put)((0, u.hideDropTarget)()): E && e(p, m, o) && (yield(0, a.put)((0, u.updateDropTarget)(m, o, s)))
            }

            function* T(e) {
                yield(0, a.throttle)(0, d.PROCESS_DROP_TARGET, S, e)
            }

            function* D(e) {
                for (;;) {
                    yield(0, a.take)(d.DROP_SELECTION);
                    const t = (0, h.selectedNodesSelector)(yield(0, a.select)()),
                        {
                            node: n,
                            dropType: o
                        } = (0, h.dropTargetSelector)(yield(0, a.select)());
                    if (n && o) {
                        const r = new CustomEvent("tree-node-drop", {
                            detail: {
                                nodes: t,
                                target: n.id,
                                type: o
                            }
                        });
                        if (e && e(r), !r.defaultPrevented) {
                            const e = (0, h.selectedIdsSelector)(yield(0, a.select)());
                            yield(0, a.put)((0, u.moveNodes)(e, n.id, o))
                        }
                    }
                }
            }

            function* _(e) {
                for (;;) {
                    yield(0, a.take)(d.MOVE_NODES);
                    e((0, h.nodesSelector)(yield(0, a.select)()))
                }
            }

            function C(e, t, n, o) {
                const r = n.length;
                let s; - 1 === o && "previous" === t && (o = r);
                let i = 0;
                for (; !s || Math.abs(i) < r && ((l = s).level > 1 && !(0, h.isExpandedSelector)(e, (0, f.ensureDefined)(l.parentId)));) i += "next" === t ? 1 : -1, s = n[(o + i + r) % r];
                var l;
                return s
            }

            function* y(e = {}) {
                const {
                    saga: t,
                    onDrop: n,
                    canMove: o,
                    onMove: r,
                    onSelect: s,
                    onKeyboardSelect: i,
                    initState: l,
                    canBeAddedToSelection: c
                } = e, u = [(0, a.fork)(T, o), (0, a.fork)(D, n), (0, a.fork)(v, s, c), (0, a.fork)(g, s, i), (0, a.fork)(E)];
                for (t && u.push((0, a.fork)(t)), r && u.push((0, a.fork)(_, r)), c && u.push((0, a.fork)(m, c));;) {
                    l && (yield(0, a.call)(p, l));
                    const e = yield(0, a.all)(u);
                    yield(0, a.take)(d.RESET_TREE);
                    for (const t of e) yield(0, a.cancel)(t)
                }
            }
            var b = n(691622),
                N = n(457825),
                M = n(758337),
                I = n(28473);
            const O = {
                ids: [],
                lastFocusedNodeId: void 0,
                isMultiSelecting: !1
            };
            const R = {
                node: void 0,
                dropType: void 0,
                boundBox: void 0
            };
            const w = (0, b.combineReducers)({
                nodes: function(e = {}, t) {
                    switch (t.type) {
                        case d.SET_NODES:
                            return t.nodes;
                        case d.SYNC_NODES:
                            {
                                const {
                                    nodes: n
                                } = t,
                                o = n.map((e => e.id)),
                                r = { ...e
                                };
                                for (const t of Object.keys(e))
                                    if (!o.includes(t)) {
                                        const {
                                            parentId: e
                                        } = r[t];
                                        e && (r[e] = { ...r[e],
                                            children: r[e].children.filter((e => e !== t))
                                        }), delete r[t]
                                    }
                                for (const e of n) {
                                    const t = e.id;
                                    if (r.hasOwnProperty(t)) {
                                        !(0, M.deepEquals)(r[t].children, e.children)[0] && (r[t] = { ...r[t],
                                            children: [...e.children]
                                        })
                                    } else {
                                        r[t] = e;
                                        const {
                                            parentId: n
                                        } = e;
                                        if (n && !r[n].children.includes(t)) throw new Error("Not implemented")
                                    }
                                }
                                return r
                            }
                        case d.UPDATE_NODE:
                            {
                                const {
                                    type: n,
                                    nodeId: o,
                                    ...r
                                } = t;
                                return { ...e,
                                    [o]: { ...e[o],
                                        ...r
                                    }
                                }
                            }
                        case d.UPDATE_NODES:
                            {
                                const {
                                    nodes: n
                                } = t,
                                o = { ...e
                                };
                                return Object.keys(n).forEach((e => {
                                    o[e] = { ...o[e],
                                        ...n[e]
                                    }
                                })),
                                { ...e,
                                    ...o
                                }
                            }
                        case d.MOVE_NODES:
                            {
                                const {
                                    ids: n,
                                    targetId: o,
                                    dropType: r
                                } = t,
                                s = (0, f.ensureDefined)(e[o].parentId),
                                i = e[s],
                                l = {};
                                for (const t of n) {
                                    const n = e[t];
                                    if (n.parentId) {
                                        const o = l[n.parentId] || e[n.parentId];
                                        l[n.parentId] = { ...o,
                                            children: o.children.filter((e => e !== t))
                                        }
                                    }
                                    l[t] = { ...n,
                                        parentId: s,
                                        level: i.level + 1
                                    }
                                }
                                const c = i.children.filter((e => !n.includes(e)));
                                return c.splice((0, I.getInsertIndex)(c, o, r), 0, ...n),
                                l[s] = { ...e[s],
                                    children: c,
                                    isExpanded: !0
                                },
                                { ...e,
                                    ...l
                                }
                            }
                        default:
                            return e
                    }
                },
                selection: function(e = O, t) {
                    switch (t.type) {
                        case d.SET_SELECTED_IDS:
                            {
                                const {
                                    ids: n
                                } = t;
                                return { ...e,
                                    ids: n,
                                    lastFocusedNodeId: n.length > 0 ? e.lastFocusedNodeId : void 0
                                }
                            }
                        case d.START_MULTI_SELECT:
                            return { ...e,
                                isMultiSelecting: !0
                            };
                        case d.STOP_MULTI_SELECT:
                            return { ...e,
                                isMultiSelecting: !1
                            };
                        case d.SET_FOCUSED_NODE:
                            return { ...e,
                                lastFocusedNodeId: t.nodeId
                            };
                        case d.SYNC_NODES:
                            {
                                const n = new Set(t.nodes.map((e => e.id)));
                                return e.lastFocusedNodeId && !n.has(e.lastFocusedNodeId) && delete e.lastFocusedNodeId,
                                { ...e,
                                    ids: e.ids.filter((e => n.has(e)))
                                }
                            }
                        default:
                            return e
                    }
                },
                dropTarget: function(e = R, t) {
                    switch (t.type) {
                        case d.UPDATE_DROP_TARGET:
                            {
                                const {
                                    node: n,
                                    dropType: o,
                                    boundBox: r
                                } = t;
                                return { ...e,
                                    node: n,
                                    dropType: o,
                                    boundBox: r
                                }
                            }
                        case d.HIDE_DROP_TARGET:
                        case d.END_DRAG:
                        case d.RESET_TREE:
                            return { ...R
                            };
                        default:
                            return e
                    }
                },
                expanded: function(e = [], t) {
                    if (t.type === d.SET_IS_EXPANDED) {
                        const {
                            nodeId: n,
                            isExpanded: o
                        } = t;
                        if (o) return [...e, n];
                        const r = [...e];
                        return r.splice(e.indexOf(n), 1), r
                    }
                    return e
                },
                disabled: function(e = [], t) {
                    return t.type === d.SET_DISABLED_NODES ? [...t.ids] : e
                },
                scrollToId: function(e = null, t) {
                    return t.type === d.SCROLL_TO_ID ? null === t.nodeId ? null : {
                        id: t.nodeId
                    } : e
                }
            });
            var x = n(497754),
                L = n.n(x),
                P = n(240933),
                k = n(130979),
                A = n(638456);
            var F = n(42357),
                W = n(298314),
                z = n(83436),
                B = n(470316),
                H = n(763341),
                U = n(962624),
                Y = n(960466);
            const G = {
                [B.Modifiers.Mod]: 1,
                [B.Modifiers.Shift]: 2
            };
            var q = n(569533),
                V = n(603950);
            const K = () => {};
            class j extends o.PureComponent {
                constructor() {
                    super(...arguments), this._ref = null, this._handleRef = e => {
                        this._ref = e;
                        const {
                            connectDragSource: t,
                            connectDropTarget: n,
                            connectDragPreview: o
                        } = this.props;
                        (0, f.ensureDefined)(n)(this._ref), (0, f.ensureDefined)(t)(this._ref), (0, f.ensureDefined)(o)((0, W.getEmptyImage)(), {
                            captureDraggingState: !0
                        })
                    }, this._handleTouchStart = e => {
                        const t = (e, t) => {
                                const n = function(e, t) {
                                    try {
                                        const n = document.createEvent("TouchEvent");
                                        return n.initTouchEvent(e, !0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, t.touches, t.targetTouches, t.changedTouches), n
                                    } catch (e) {
                                        return null
                                    }
                                }(e, t);
                                if (n) return n;
                                const o = Array.from(t.changedTouches),
                                    r = Array.from(t.touches),
                                    s = Array.from(t.targetTouches);
                                return new TouchEvent(e, {
                                    bubbles: !0,
                                    changedTouches: o,
                                    touches: r,
                                    targetTouches: s
                                })
                            },
                            n = e.target;
                        if (n instanceof Element) {
                            const e = e => {
                                    const o = e;
                                    if (!n.isConnected) {
                                        o.preventDefault();
                                        const e = t("touchmove", o);
                                        document.body.dispatchEvent(e)
                                    }
                                },
                                o = r => {
                                    const s = r;
                                    if (!n.isConnected) {
                                        s.preventDefault();
                                        const e = t("touchend", s);
                                        document.body.dispatchEvent(e)
                                    }
                                    n.removeEventListener("touchend", o), n.removeEventListener("touchmove", e)
                                };
                            n.addEventListener("touchend", o), n.addEventListener("touchmove", e)
                        }
                    }
                }
                componentDidMount() {
                    var e;
                    null === (e = this._ref) || void 0 === e || e.addEventListener("touchstart", this._handleTouchStart)
                }
                componentWillUnmount() {
                    var e;
                    null === (e = this._ref) || void 0 === e || e.removeEventListener("touchstart", this._handleTouchStart)
                }
                render() {
                    return o.createElement(X, { ...this.props,
                        reference: this._handleRef
                    })
                }
                getNode() {
                    return (0, f.ensureNotNull)(this._ref)
                }
            }
            const X = e => {
                    const {
                        id: t,
                        isSelected: n,
                        isOffset: r,
                        isExpandable: s,
                        setIsSelected: i,
                        isDisabled: l,
                        isExpanded: c,
                        onClick: a,
                        parentId: d,
                        setIsExpanded: u,
                        reference: h,
                        isFirstListItem: p,
                        isLastListItem: f,
                        nodeRenderer: m,
                        isChildOfSelected: E = !1
                    } = e, {
                        size: g,
                        smallSizeTreeNodeAction: v
                    } = (0, o.useContext)(Y.SizeContext), S = (0, o.useRef)(null), T = (0, H.createSafeMulticastEventHandler)((e => S.current = e), h);
                    let [D, _] = (0, U.useHover)();
                    return (A.CheckMobile.any() || A.CheckMobile.isIPad()) && (D = n, _ = {
                        onMouseOut: K,
                        onMouseOver: K
                    }), o.createElement("div", {
                        className: x(V.wrap, n && V.selected, E && V.childOfSelected, l && V.disabled, s && V.expandable),
                        onClick: 1 === g && 0 === v ? C : function(e) {
                            if (e.defaultPrevented) return;
                            const o = G[(0, B.modifiersFromEvent)(e)] || 0;
                            !l && i && i(t, !n, o);
                            a && 0 === o && a(e, t)
                        },
                        onContextMenu: C,
                        ref: T,
                        ..._
                    }, s && o.createElement(z.Icon, {
                        icon: q,
                        className: x(V.expandHandle, c && V.expanded),
                        onClick: function(e) {
                            e.preventDefault(), s && u(t, !c)
                        },
                        onMouseDown: function(e) {
                            e.preventDefault()
                        }
                    }), m({
                        id: t,
                        isOffset: r,
                        parentId: d,
                        isDisabled: l,
                        isSelected: n,
                        isChildOfSelected: E,
                        isHovered: D,
                        isExpanded: c,
                        isFirstListItem: p,
                        isLastListItem: f
                    }));

                    function C() {
                        l || n || !i || i(t, !0)
                    }
                },
                $ = o.createContext({});

            function Z(e, t) {
                const {
                    id: n
                } = t, o = (0, h.nodeSelector)(e, n), r = (0, h.isSelectedSelector)(e, n);
                let s = !1,
                    i = o.parentId;
                for (; i && !s;) s = (0, h.isSelectedSelector)(e, i), i = (0, h.nodeSelector)(e, i).parentId;
                return { ...o,
                    isSelected: r,
                    isChildOfSelected: s,
                    isExpanded: o.children.length > 0 && (0, h.isExpandedSelector)(e, n),
                    isExpandable: o.children.length > 0,
                    isDisabled: (0, h.isDisabledSelector)(e, n)
                }
            }

            function J(e) {
                return (0, b.bindActionCreators)({
                    setIsExpanded: u.setIsExpanded,
                    processDropTarget: u.processDropTarget,
                    dropSelection: u.dropSelection,
                    selectNext: u.selectNext,
                    selectPrevious: u.selectPrevious,
                    setIsSelected: u.setIsSelected,
                    endDrag: u.endDrag
                }, e)
            }
            const Q = (0, s.connect)(Z, J, null, {
                    context: $
                })((function(e) {
                    const t = (0, o.useRef)(null),
                        [, n, r] = (0, F.useDrag)({
                            type: "node",
                            item: t => {
                                const {
                                    id: n,
                                    isDisabled: o,
                                    isSelected: r
                                } = e;
                                return o || r || e.setIsSelected(n, !0), e
                            },
                            end: e => {
                                e.endDrag()
                            }
                        }),
                        [, s] = (0, P.useDrop)({
                            accept: "node",
                            hover: (n, o) => {
                                const r = t.current;
                                if (!r) return;
                                const s = r.getNode(),
                                    i = s.getBoundingClientRect(),
                                    l = i.bottom - i.top,
                                    c = o.getClientOffset();
                                if (c) {
                                    const t = c.y - i.top;
                                    let n, o;
                                    if (n = 0 === e.children.length ? t < l / 2 ? "before" : "after" : t < l / 3 ? "before" : e.isExpanded || t >= l / 3 && t < 2 * l / 3 ? "inside" : "after", void 0 !== e.getContainerElement) {
                                        const t = e.getContainerElement().getBoundingClientRect();
                                        o = {
                                            top: i.top - t.top,
                                            left: i.left - t.left,
                                            bottom: i.top - t.top + i.height,
                                            right: i.left - t.left + i.width,
                                            height: i.height,
                                            width: i.width
                                        }
                                    } else o = {
                                        top: s.offsetTop,
                                        left: s.offsetLeft,
                                        bottom: s.offsetTop + s.offsetHeight,
                                        right: s.offsetLeft + s.offsetWidth,
                                        height: s.offsetHeight,
                                        width: s.offsetWidth
                                    };
                                    e.processDropTarget(e, n, c.x - i.left < 48, o, e.isLastChild)
                                }
                            }
                        });
                    return o.createElement(j, { ...e,
                        connectDragSource: n,
                        connectDropTarget: s,
                        connectDragPreview: r,
                        ref: t
                    })
                })),
                ee = (0, s.connect)(Z, J, null, {
                    context: $
                })(X);
            var te = n(515312),
                ne = n(85783),
                oe = n(707533);

            function re(e) {
                const t = e(),
                    n = (0, o.useRef)(t);
                n.current = t;
                const [r, s] = (0, o.useState)(n.current), i = (0, o.useRef)(null);
                return (0, o.useEffect)((() => {
                    null === i.current && (i.current = requestAnimationFrame((() => {
                        i.current = null, s(n.current)
                    })))
                })), (0, o.useEffect)((() => () => {
                    i.current && cancelAnimationFrame(i.current)
                }), []), r
            }

            function se(e) {
                const {
                    dropTargetOffset: t,
                    mousePosition: n
                } = e;
                if (!t) return {
                    display: "none"
                };
                const {
                    x: o,
                    y: r
                } = t, s = n && t ? n.y - t.y : 0, i = `translate(${o+(n&&t?n.x-t.x:0)}px, ${r+s}px)`;
                return {
                    transform: i,
                    WebkitTransform: i
                }
            }
            const ie = {
                top: 0,
                left: 0,
                position: "fixed",
                pointerEvents: "none",
                zIndex: 100,
                opacity: .5,
                width: 300,
                backgroundColor: "red"
            };

            function le(e) {
                return {
                    isDragging: e.isDragging() && "node" === e.getItemType(),
                    mousePosition: e.getClientOffset(),
                    dropTargetOffset: e.getSourceClientOffset()
                }
            }
            const ce = (0, s.connect)((function(e) {
                return {
                    items: (0, h.renderDragListSelector)(e)
                }
            }), null, null, {
                context: $
            })((function(e) {
                const {
                    items: t,
                    isDragging: n,
                    nodeRenderer: r,
                    dragPreviewRenderer: s
                } = e;
                return re((function() {
                    return n ? o.createElement(oe.Portal, null, o.createElement("div", {
                        style: { ...ie,
                            ...se(e)
                        }
                    }, t.map((e => {
                        if (s) {
                            const t = s;
                            return o.createElement(t, {
                                key: e.id,
                                ...e
                            })
                        }
                        return o.createElement(ee, {
                            id: e.id,
                            key: e.id,
                            nodeRenderer: r,
                            isDragPreview: !0,
                            isOffset: e.level > 1
                        })
                    })))) : null
                }))
            }));

            function ae(e) {
                return o.createElement(ce, { ...e,
                    ...(0, ne.useDragLayer)(le)
                })
            }
            var de = n(890523),
                ue = n(451860),
                he = n(445343);
            const pe = o.forwardRef(((e, t) => {
                const n = (0, o.useRef)(null);
                return e.connectDropTarget(n), (0, o.useImperativeHandle)(t, (() => ({
                    getNode: () => (0, f.ensureNotNull)(n.current)
                })), []), o.createElement("div", {
                    ref: n,
                    style: {
                        height: "100%",
                        width: "100%"
                    }
                })
            }));

            function fe(e) {
                const t = (0, o.useRef)(null),
                    [, n] = (0, P.useDrop)({
                        accept: "node",
                        hover: (n, o) => {
                            if (!t.current) return;
                            const r = o.getClientOffset();
                            if (null === r) return;
                            const s = e.getOrderedNodes();
                            if (0 === s.length) return;
                            const i = t.current.getNode().getBoundingClientRect(),
                                l = e.getContainerElement().getBoundingClientRect();
                            if ("first" === e.type) {
                                const t = {
                                    top: i.top - l.top + i.height,
                                    left: i.left - l.left,
                                    bottom: i.top - l.top + i.height,
                                    right: i.left - l.left + i.width,
                                    height: 0,
                                    width: i.width
                                };
                                e.processDropTarget(s[0], "before", !1, t, !1)
                            }
                            if ("last" === e.type) {
                                const t = r.x - i.left < 48,
                                    n = s[s.length - 1],
                                    o = t && 2 === n.level ? (0, f.ensureDefined)(s.find((e => e.id === n.parentId))) : n,
                                    c = {
                                        top: i.top - l.top,
                                        left: i.left - l.left,
                                        bottom: i.top - l.top,
                                        right: i.left - l.left + i.width,
                                        height: i.height,
                                        width: i.width
                                    };
                                e.processDropTarget(o, "after", t, c, !1)
                            }
                        }
                    });
                return o.createElement(pe, { ...e,
                    connectDropTarget: n,
                    ref: t
                })
            }
            const me = o.createContext({
                isOver: !1,
                transform: void 0
            });
            var Ee = n(820577);

            function ge(e) {
                const {
                    dropType: t,
                    boundBox: n
                } = e, {
                    top: o,
                    bottom: r,
                    left: s
                } = (0, f.ensureDefined)(n);
                return [s, "before" === t || "inside" === t ? o : r]
            }

            function ve(e) {
                return {
                    isDragging: e.isDragging()
                }
            }
            const Se = (0, s.connect)((function(e) {
                const {
                    boundBox: t,
                    dropType: n,
                    node: o
                } = (0, h.dropTargetSelector)(e);
                return {
                    boundBox: t,
                    dropType: n,
                    level: o ? o.level : void 0
                }
            }), null, null, {
                context: $
            })((function(e) {
                const {
                    dropType: t,
                    boundBox: n,
                    isDragging: r,
                    level: s,
                    transform: i = ge
                } = e;
                return re((function() {
                    if (!r || !t || !n) return null;
                    const l = {
                            [Ee.dropTarget]: "inside" !== t,
                            [Ee.dropTargetInside]: "inside" === t
                        },
                        {
                            width: c,
                            height: a
                        } = n,
                        [d, u] = i(e),
                        h = `translate(${d}px, ${u}px)`;
                    return o.createElement("div", {
                        className: x(l),
                        style: {
                            position: "absolute",
                            transform: h,
                            WebkitTransform: h,
                            top: 0,
                            left: 2 === s ? "46px" : 0,
                            width: 2 === s ? c - 46 + "px" : c,
                            height: "inside" === t ? a : "2px"
                        }
                    })
                }))
            }));

            function Te(e) {
                const {
                    isDragging: t
                } = (0, ne.useDragLayer)(ve);
                return o.createElement(Se, { ...e,
                    isDragging: t
                })
            }
            const De = o.forwardRef(((e, t) => {
                const n = (0, o.useContext)(me);
                return o.createElement("div", { ...e,
                    ref: t
                }, e.children, n.isOver && o.createElement(Te, {
                    transform: n.transform
                }))
            }));
            var _e = n(768038),
                Ce = n(643380);
            const ye = 38 + B.Modifiers.Shift,
                be = 40 + B.Modifiers.Shift;
            const Ne = o.forwardRef((function(e, t) {
                const {
                    navigationKeys: n,
                    renderList: r,
                    stopMultiSelect: s,
                    startMultiSelect: i,
                    isMultiSelecting: l,
                    nodeRenderer: c,
                    dragPreviewRenderer: a,
                    className: d,
                    connectDropTarget: u,
                    readOnly: h,
                    onClick: p,
                    dropLayerTransform: m,
                    setFocusedNode: E,
                    scrollToId: g,
                    rowHeight: v,
                    onMultiSelectPrevious: S,
                    onMultiSelectNext: T,
                    onMoveCursorToNext: D,
                    onMoveCursorToPrevious: _,
                    onKeyDown: C,
                    outerRef: y,
                    width: b,
                    height: N,
                    isOver: M,
                    processDropTarget: I,
                    autofocus: O
                } = e, R = (0, o.useContext)(de.ObjectTreeContext), w = (0, o.useRef)(null);
                (0, o.useEffect)((() => {
                    var e;
                    O && (null === (e = w.current) || void 0 === e || e.focus())
                }), []), (0, o.useEffect)((() => {
                    const e = e => {
                            [B.Modifiers.Mod, B.Modifiers.Shift].includes((0, B.modifiersFromEvent)(e)) && i()
                        },
                        t = e => {
                            l && ![B.Modifiers.Mod, B.Modifiers.Shift].includes((0, B.modifiersFromEvent)(e)) && s()
                        };
                    return document.addEventListener("keydown", e), document.addEventListener("keyup", t), document.addEventListener("mousemove", t), () => {
                        document.removeEventListener("keydown", e), document.removeEventListener("keyup", t), document.removeEventListener("mousemove", t)
                    }
                }), [l]),
                function(e) {
                    (0, o.useEffect)((() => {
                        if (A.isEdge) {
                            let t = null;
                            const n = (0, f.ensureNotNull)(e.current),
                                o = e => {
                                    if (e.target instanceof Element) {
                                        const n = (0, f.ensureNotNull)(e.target.closest("[draggable]"));
                                        n instanceof HTMLElement && (n.style.opacity = "0", t = requestAnimationFrame((() => n.style.opacity = "1")))
                                    }
                                };
                            return n.addEventListener("dragstart", o), () => {
                                n.removeEventListener("dragstart", o), null !== t && cancelAnimationFrame(t)
                            }
                        }
                        return () => {}
                    }), [])
                }(w);
                const x = (0, o.useCallback)((() => (0, f.ensureNotNull)(X.current)), []),
                    P = (0, o.useCallback)((() => r), [r]),
                    F = (0, o.useMemo)((() => {
                        const e = h ? ee : Q,
                            t = [];
                        let n;
                        t.push({
                            type: "padding",
                            node: o.createElement(fe, {
                                type: "first",
                                key: "padding-top",
                                getContainerElement: x,
                                getOrderedNodes: P,
                                processDropTarget: I
                            })
                        });
                        for (let s = 0; s < r.length; s++) {
                            const i = r[s];
                            1 === i.level && (void 0 !== n && n !== i.parentId && t.push({
                                type: "separator",
                                node: o.createElement("div", {
                                    key: n + "_separator",
                                    className: Ce.separator
                                })
                            }), n = i.parentId), t.push({
                                type: "node",
                                node: o.createElement(e, {
                                    id: i.id,
                                    key: i.id,
                                    isFirstListItem: 0 === s,
                                    isLastListItem: s === r.length - 1,
                                    isExpandable: i.children.length > 0,
                                    nodeRenderer: c,
                                    readOnly: h,
                                    onClick: p,
                                    isOffset: i.level > 1,
                                    getContainerElement: x
                                })
                            })
                        }
                        return t.push({
                            type: "padding",
                            node: o.createElement(fe, {
                                type: "last",
                                key: "padding-bottom",
                                getContainerElement: x,
                                getOrderedNodes: P,
                                processDropTarget: I
                            })
                        }), t
                    }), [r]),
                    W = (0, o.useRef)([]);
                W.current = F;
                const z = (0, o.useCallback)((e => {
                        let {
                            style: t
                        } = e;
                        const {
                            index: n
                        } = e;
                        return n === W.current.length - 1 && (t = { ...t,
                            bottom: 0,
                            minHeight: t.height
                        }, delete t.height), o.createElement("div", {
                            style: t
                        }, W.current[n].node)
                    }), []),
                    H = (0, o.useCallback)((e => {
                        const t = W.current[e];
                        return "padding" === t.type ? 6 : "function" == typeof v ? v(e, t) : v
                    }), [v]),
                    U = (0, o.useCallback)((e => (0, f.ensure)(W.current[e].node.key)), []),
                    Y = (0, o.useMemo)((() => null === g ? {
                        index: -1
                    } : {
                        index: W.current.findIndex((e => e.node.key === g.id))
                    }), [g]);
                u(w);
                const [G, q, V, K] = (0, he.useOverlayScroll)(), j = (0, o.useRef)(null);
                (0, o.useEffect)((() => (0, f.ensureNotNull)(j.current).resetAfterIndex(0, !0)), [F]), (0, o.useEffect)((() => (0, f.ensureNotNull)(j.current).scrollToItem(Y.index)), [Y]);
                const X = (0, o.useRef)(null),
                    $ = (0, o.useMemo)((() => ({
                        isOver: M,
                        transform: m
                    })), [M, m]),
                    Z = (0, o.useRef)(null),
                    J = (0, o.useRef)({
                        startScroll(e) {
                            const t = () => {
                                null !== V.current && (Z.current = requestAnimationFrame(t), V.current.scrollBy({
                                    top: e
                                }))
                            };
                            this.stopScroll(), t()
                        },
                        stopScroll() {
                            null !== Z.current && (cancelAnimationFrame(Z.current), Z.current = null)
                        },
                        getListElement: () => V.current
                    });
                return (0, o.useImperativeHandle)(t, (() => J.current), []), (0, o.useEffect)((() => () => J.current.stopScroll()), [M]), o.createElement(me.Provider, {
                    value: $
                }, o.createElement("div", { ...q,
                    className: L()(Ce.tree, d),
                    ref: w,
                    tabIndex: -1,
                    onKeyDown: function(e) {
                        const t = (0, B.hashFromEvent)(e);
                        if (e.defaultPrevented || (0, te.isNativeUIInteraction)(t, e.target)) return;
                        R || t !== ye || (e.preventDefault(), S());
                        R || t !== be || (e.preventDefault(), T());
                        (38 === t || void 0 !== n && "previous" === n[t]) && (e.preventDefault(), _());
                        (40 === t || void 0 !== n && "next" === n[t]) && (e.preventDefault(), D());
                        if ((8 === t || 46 === t) && R) {
                            const {
                                viewModel: e
                            } = R, t = e.selection(), n = t.selected();
                            if (1 !== n.length) return;
                            const o = e.getNextNodeIdAfterRemove(n[0]);
                            if (null === o) return;
                            e.onChange().subscribe(null, (() => {
                                if (t.selected().length) return;
                                const n = e.entity(o);
                                n && (t.set([n]), E(o))
                            }), !0)
                        }
                        null == C || C(e)
                    }
                }, o.createElement(ue.OverlayScrollContainer, { ...G,
                    className: Ce.overlayScrollWrap
                }), o.createElement(k.VariableSizeList, {
                    ref: function(e) {
                        j.current = e
                    },
                    className: Ce.listContainer,
                    width: b,
                    height: N,
                    itemCount: F.length,
                    itemSize: H,
                    children: z,
                    itemKey: U,
                    outerRef: function(e) {
                        V.current = e, y && y(e)
                    },
                    innerRef: function(e) {
                        X.current = e
                    },
                    innerElementType: De,
                    onItemsRendered: function() {
                        K()
                    },
                    overscanCount: 20,
                    direction: (0, _e.isRtl)() ? "rtl" : "ltr"
                }), o.createElement(ae, {
                    dragPreviewRenderer: a,
                    nodeRenderer: c
                })))
            }));
            const Me = (0, s.connect)((function(e) {
                    return {
                        renderList: (0, h.renderListSelector)(e),
                        orderedNodes: (0,
                            h.orderedNodesSelector)(e),
                        isMultiSelecting: (0, h.isMultiSelectingSelector)(e),
                        selectedIds: (0, h.selectedIdsSelector)(e),
                        scrollToId: (0, h.scrollToIdSelector)(e)
                    }
                }), (function(e) {
                    return (0, b.bindActionCreators)({
                        startMultiSelect: u.startMultiSelect,
                        stopMultiSelect: u.stopMultiSelect,
                        setFocusedNode: u.setFocusedNode,
                        processDropTarget: u.processDropTarget,
                        onMoveCursorToNext: u.selectNext,
                        onMoveCursorToPrevious: u.selectPrevious,
                        onMultiSelectPrevious: u.multiSelectPrevious,
                        onMultiSelectNext: u.multiSelectNext
                    }, e)
                }), null, {
                    context: $
                })((function(e) {
                    const t = (0, o.useRef)(null),
                        [{
                            isOver: n
                        }, r] = (0, P.useDrop)({
                            accept: "node",
                            drop: (n, o) => {
                                var r;
                                ("touch" === e.drag || A.isFF) && (null === (r = t.current) || void 0 === r || r.stopScroll()), o.getItem().dropSelection()
                            },
                            hover: (n, o) => {
                                var r, s;
                                if ("touch" !== e.drag && !A.isFF) return;
                                const i = o.getClientOffset();
                                if (null === i) return;
                                const l = null !== (s = null === (r = t.current) || void 0 === r ? void 0 : r.getListElement()) && void 0 !== s ? s : null;
                                if (null === l) return;
                                const c = l.getBoundingClientRect();
                                ((n, o, r) => {
                                    var s;
                                    const i = Math.abs(n - r),
                                        l = Math.abs(n - o);
                                    if (l > 40 && i > 40 || i <= 40 && l <= 40) return void(null === (s = t.current) || void 0 === s || s.stopScroll());
                                    ((n, o, r, s) => {
                                        var i, l, c, a;
                                        o || n ? "touch" === e.drag ? null === (i = t.current) || void 0 === i || i.startScroll(o ? -5 : 5) : null === (l = t.current) || void 0 === l || l.startScroll(o ? -2 : 2) : (r || s) && ("touch" === e.drag ? null === (c = t.current) || void 0 === c || c.startScroll(r ? -10 : 10) : null === (a = t.current) || void 0 === a || a.startScroll(r ? -5 : 5))
                                    })(l > 20 && l <= 40, i > 20 && i <= 40, i <= 20, l <= 20)
                                })(i.y, c.bottom, c.top)
                            },
                            collect: e => ({
                                isOver: e.isOver()
                            })
                        });
                    return o.createElement(Ne, { ...e,
                        isOver: n,
                        connectDropTarget: r,
                        ref: t
                    })
                })),
                Ie = {
                    delayTouchStart: 100
                };

            function Oe(e) {
                const {
                    canBeAddedToSelection: t,
                    initState: n,
                    onSelect: s,
                    canMove: i,
                    onDrop: l,
                    onMove: c,
                    nodes: a,
                    selectedIds: d,
                    onKeyboardSelect: h,
                    saga: p,
                    lastFocusedNodeObject: f,
                    lastSyncTimestampRef: m,
                    scrollToId: E,
                    ...g
                } = e, [v, S] = (0, o.useState)(null);
                return (0, o.useEffect)((() => {
                    const e = (0, r.default)();
                    S(function(e) {
                        const t = (0, N.composeWithDevTools)((0, b.applyMiddleware)(e));
                        return (0, b.createStore)(w, t)
                    }(e));
                    const o = e.run(y, {
                        initState: n,
                        onKeyboardSelect: h,
                        saga: p,
                        canMove: i,
                        onMove: c,
                        onDrop: l,
                        onSelect: s,
                        canBeAddedToSelection: t
                    });
                    return () => o.cancel()
                }), []), (0, o.useEffect)((() => (null !== v && a && (m && (m.current = performance.now()), v.dispatch((0, u.syncNodes)(a))), () => {})), [v, a]), (0, o.useEffect)((() => {
                    null !== v && d && v.dispatch((0, u.setSelectedIds)(d))
                }), [v, d]), (0, o.useEffect)((() => {
                    null !== v && (null == f ? void 0 : f.id) && v.dispatch((0, u.setFocusedNode)(f.id))
                }), [v, f]), null === v ? null : o.createElement(Re, {
                    store: v,
                    scrollToId: E,
                    ...g
                })
            }
            const Re = o.memo((function(e) {
                const {
                    store: t,
                    scrollToId: n,
                    ...r
                } = e, a = "touch" === e.drag ? l.TouchBackend : i.HTML5Backend;
                return (0, o.useEffect)((() => {
                    var e;
                    t.dispatch((0, u.scrollToId)(null !== (e = null == n ? void 0 : n.id) && void 0 !== e ? e : null))
                }), [n]), o.createElement(c.DndProvider, {
                    backend: a,
                    options: Ie
                }, o.createElement(s.Provider, {
                    store: t,
                    context: $
                }, o.createElement(Me, { ...r
                })))
            }))
        },
        890523: (e, t, n) => {
            "use strict";
            n.d(t, {
                ObjectTreeContext: () => o
            });
            const o = n(50959).createContext(null)
        },
        951292: (e, t, n) => {
            "use strict";
            n.d(t, {
                useOutsideEvent: () => s
            });
            var o = n(50959),
                r = n(314308);

            function s(e) {
                const {
                    click: t,
                    mouseDown: n,
                    touchEnd: s,
                    touchStart: i,
                    handler: l,
                    reference: c,
                    ownerDocument: a = document
                } = e, d = (0, o.useRef)(null), u = (0, o.useRef)(new CustomEvent("timestamp").timeStamp);
                return (0, o.useLayoutEffect)((() => {
                    const e = {
                            click: t,
                            mouseDown: n,
                            touchEnd: s,
                            touchStart: i
                        },
                        o = c ? c.current : d.current;
                    return (0, r.addOutsideEventListener)(u.current, o, l, a, e)
                }), [t, n, s, i, l]), c || d
            }
        },
        445343: (e, t, n) => {
            "use strict";
            n.d(t, {
                useOverlayScroll: () => c
            });
            var o = n(50959),
                r = n(650151),
                s = n(962624),
                i = n(638456);
            const l = {
                onMouseOver: () => {},
                onMouseOut: () => {}
            };

            function c(e, t = i.CheckMobile.any()) {
                const n = (0, o.useRef)(null),
                    c = e || (0, o.useRef)(null),
                    [a, d] = (0, s.useHover)(),
                    [u, h] = (0, o.useState)({
                        reference: n,
                        containerHeight: 0,
                        containerWidth: 0,
                        contentHeight: 0,
                        contentWidth: 0,
                        scrollPosTop: 0,
                        scrollPosLeft: 0,
                        onVerticalChange: function(e) {
                            h((t => ({ ...t,
                                scrollPosTop: e
                            }))), (0, r.ensureNotNull)(c.current).scrollTop = e
                        },
                        onHorizontalChange: function(e) {
                            h((t => ({ ...t,
                                scrollPosLeft: e
                            }))), (0, r.ensureNotNull)(c.current).scrollLeft = e
                        },
                        visible: a
                    }),
                    p = (0, o.useCallback)((() => {
                        if (!c.current) return;
                        const {
                            clientHeight: e,
                            scrollHeight: t,
                            scrollTop: o,
                            clientWidth: r,
                            scrollWidth: s,
                            scrollLeft: i
                        } = c.current, l = n.current ? n.current.offsetTop : 0;
                        h((n => ({ ...n,
                            containerHeight: e - l,
                            contentHeight: t - l,
                            scrollPosTop: o,
                            containerWidth: r,
                            contentWidth: s,
                            scrollPosLeft: i
                        })))
                    }), []);

                function f() {
                    h((e => ({ ...e,
                        scrollPosTop: (0, r.ensureNotNull)(c.current).scrollTop,
                        scrollPosLeft: (0, r.ensureNotNull)(c.current).scrollLeft
                    })))
                }
                return (0, o.useEffect)((() => {
                    a && p(), h((e => ({ ...e,
                        visible: a
                    })))
                }), [a]), (0, o.useEffect)((() => {
                    const e = c.current;
                    return e && e.addEventListener("scroll", f), () => {
                        e && e.removeEventListener("scroll", f)
                    }
                }), [c]), [u, t ? l : d, c, p]
            }
        },
        148547: (e, t, n) => {
            "use strict";
            n.d(t, {
                ListItemButton: () => c
            });
            var o = n(50959),
                r = n(497754),
                s = n.n(r),
                i = n(83436),
                l = n(734393);

            function c(e) {
                const {
                    className: t,
                    disabled: n,
                    ...r
                } = e;
                return o.createElement(i.Icon, {
                    className: s()(l.button, n && l.disabled, t),
                    ...r
                })
            }
        },
        377318: (e, t, n) => {
            "use strict";
            n.d(t, {
                MenuContext: () => o
            });
            const o = n(50959).createContext(null)
        },
        175071: (e, t, n) => {
            "use strict";
            n.d(t, {
                DEFAULT_MENU_THEME: () => E,
                Menu: () => g
            });
            var o = n(50959),
                r = n(497754),
                s = n.n(r),
                i = n(650151),
                l = n(43329),
                c = n(587080),
                a = n(670797),
                d = n(224743),
                u = n(829725),
                h = n(799786),
                p = n(787684),
                f = n(377318),
                m = n(409790);
            const E = m;
            class g extends o.PureComponent {
                constructor(e) {
                    super(e), this._containerRef = null, this._scrollWrapRef = null, this._raf = null, this._scrollRaf = null, this._scrollTimeout = void 0, this._manager = new u.OverlapManager, this._hotkeys = null, this._scroll = 0, this._handleContainerRef = e => {
                        this._containerRef = e, this.props.reference && ("function" == typeof this.props.reference && this.props.reference(e), "object" == typeof this.props.reference && (this.props.reference.current = e))
                    }, this._handleScrollWrapRef = e => {
                        this._scrollWrapRef = e, "function" == typeof this.props.scrollWrapReference && this.props.scrollWrapReference(e), "object" == typeof this.props.scrollWrapReference && (this.props.scrollWrapReference.current = e)
                    }, this._handleMeasure = ({
                        callback: e,
                        forceRecalcPosition: t
                    } = {}) => {
                        var n, o, r, s, c, a, d, u, h, p, f, m;
                        if (this.state.isMeasureValid && !t) return;
                        const {
                            position: E
                        } = this.props, g = (0, i.ensureNotNull)(this._containerRef);
                        let v = g.getBoundingClientRect();
                        const S = document.documentElement.clientHeight,
                            T = document.documentElement.clientWidth,
                            D = null !== (n = this.props.closeOnScrollOutsideOffset) && void 0 !== n ? n : 0;
                        let _ = S - 0 - D;
                        const C = v.height > _;
                        if (C) {
                            (0, i.ensureNotNull)(this._scrollWrapRef).style.overflowY = "scroll", v = g.getBoundingClientRect()
                        }
                        const {
                            width: y,
                            height: b
                        } = v, N = "function" == typeof E ? E(y, b, S) : E, M = null !== (r = null === (o = null == N ? void 0 : N.indentFromWindow) || void 0 === o ? void 0 : o.left) && void 0 !== r ? r : 0, I = T - (null !== (s = N.overrideWidth) && void 0 !== s ? s : y) - (null !== (a = null === (c = null == N ? void 0 : N.indentFromWindow) || void 0 === c ? void 0 : c.right) && void 0 !== a ? a : 0), O = (0, l.clamp)(N.x, M, Math.max(M, I)), R = (null !== (u = null === (d = null == N ? void 0 : N.indentFromWindow) || void 0 === d ? void 0 : d.top) && void 0 !== u ? u : 0) + D, w = S - (null !== (h = N.overrideHeight) && void 0 !== h ? h : b) - (null !== (f = null === (p = null == N ? void 0 : N.indentFromWindow) || void 0 === p ? void 0 : p.bottom) && void 0 !== f ? f : 0);
                        let x = (0, l.clamp)(N.y, R, Math.max(R, w));
                        if (N.forbidCorrectYCoord && x < N.y && (_ -= N.y - x, x = N.y), t && void 0 !== this.props.closeOnScrollOutsideOffset && N.y <= this.props.closeOnScrollOutsideOffset) return void this._handleGlobalClose(!0);
                        const L = null !== (m = N.overrideHeight) && void 0 !== m ? m : C ? _ : void 0;
                        this.setState({
                            appearingMenuHeight: t ? this.state.appearingMenuHeight : L,
                            appearingMenuWidth: t ? this.state.appearingMenuWidth : N.overrideWidth,
                            appearingPosition: {
                                x: O,
                                y: x
                            },
                            isMeasureValid: !0
                        }, (() => {
                            this._restoreScrollPosition(), e && e()
                        }))
                    }, this._restoreScrollPosition = () => {
                        const e = document.activeElement,
                            t = (0, i.ensureNotNull)(this._containerRef);
                        if (null !== e && t.contains(e)) try {
                            e.scrollIntoView()
                        } catch (e) {} else(0, i.ensureNotNull)(this._scrollWrapRef).scrollTop = this._scroll
                    }, this._resizeForced = () => {
                        this.setState({
                            appearingMenuHeight: void 0,
                            appearingMenuWidth: void 0,
                            appearingPosition: void 0,
                            isMeasureValid: void 0
                        })
                    }, this._resize = () => {
                        null === this._raf && (this._raf = requestAnimationFrame((() => {
                            this.setState({
                                appearingMenuHeight: void 0,
                                appearingMenuWidth: void 0,
                                appearingPosition: void 0,
                                isMeasureValid: void 0
                            }), this._raf = null
                        })))
                    }, this._handleGlobalClose = e => {
                        this.props.onClose(e)
                    }, this._handleSlot = e => {
                        this._manager.setContainer(e)
                    }, this._handleScroll = () => {
                        this._scroll = (0, i.ensureNotNull)(this._scrollWrapRef).scrollTop
                    }, this._handleScrollOutsideEnd = () => {
                        clearTimeout(this._scrollTimeout), this._scrollTimeout = setTimeout((() => {
                            this._handleMeasure({
                                forceRecalcPosition: !0
                            })
                        }), 80)
                    }, this._handleScrollOutside = e => {
                        e.target !== this._scrollWrapRef && (this._handleScrollOutsideEnd(), null === this._scrollRaf && (this._scrollRaf = requestAnimationFrame((() => {
                            this._handleMeasure({
                                forceRecalcPosition: !0
                            }), this._scrollRaf = null
                        }))))
                    }, this.state = {}
                }
                componentDidMount() {
                    this._handleMeasure({
                        callback: this.props.onOpen
                    });
                    const {
                        customCloseDelegate: e = d.globalCloseDelegate
                    } = this.props;
                    e.subscribe(this, this._handleGlobalClose), window.addEventListener("resize", this._resize);
                    const t = null !== this.context;
                    this._hotkeys || t || (this._hotkeys = h.createGroup({
                        desc: "Popup menu"
                    }), this._hotkeys.add({
                        desc: "Close",
                        hotkey: 27,
                        handler: () => {
                            this.props.onKeyboardClose && this.props.onKeyboardClose(), this._handleGlobalClose()
                        }
                    })), this.props.repositionOnScroll && window.addEventListener("scroll", this._handleScrollOutside, {
                        capture: !0
                    })
                }
                componentDidUpdate() {
                    this._handleMeasure()
                }
                componentWillUnmount() {
                    const {
                        customCloseDelegate: e = d.globalCloseDelegate
                    } = this.props;
                    e.unsubscribe(this, this._handleGlobalClose), window.removeEventListener("resize", this._resize), window.removeEventListener("scroll", this._handleScrollOutside, {
                        capture: !0
                    }), this._hotkeys && (this._hotkeys.destroy(), this._hotkeys = null), null !== this._raf && (cancelAnimationFrame(this._raf), this._raf = null), null !== this._scrollRaf && (cancelAnimationFrame(this._scrollRaf), this._scrollRaf = null), this._scrollTimeout && clearTimeout(this._scrollTimeout)
                }
                render() {
                    const {
                        id: e,
                        role: t,
                        "aria-label": n,
                        "aria-labelledby": r,
                        "aria-activedescendant": i,
                        "aria-hidden": l,
                        children: d,
                        minWidth: u,
                        theme: h = m,
                        className: E,
                        maxHeight: g,
                        onMouseOver: S,
                        onMouseOut: T,
                        onKeyDown: D,
                        onFocus: _,
                        onBlur: C
                    } = this.props, {
                        appearingMenuHeight: y,
                        appearingMenuWidth: b,
                        appearingPosition: N,
                        isMeasureValid: M
                    } = this.state;
                    return o.createElement(f.MenuContext.Provider, {
                        value: this
                    }, o.createElement(p.SubmenuHandler, null, o.createElement(a.SlotContext.Provider, {
                        value: this._manager
                    }, o.createElement("div", {
                        id: e,
                        role: t,
                        "aria-label": n,
                        "aria-labelledby": r,
                        "aria-activedescendant": i,
                        "aria-hidden": l,
                        className: s()(E, h.menuWrap, !M && h.isMeasuring),
                        style: {
                            height: y,
                            left: N && N.x,
                            minWidth: u,
                            position: "fixed",
                            top: N && N.y,
                            width: b
                        },
                        "data-name": this.props["data-name"],
                        ref: this._handleContainerRef,
                        onScrollCapture: this.props.onScroll,
                        onContextMenu: c.preventDefaultForContextMenu,
                        tabIndex: this.props.tabIndex,
                        onMouseOver: S,
                        onMouseOut: T,
                        onKeyDown: D,
                        onFocus: _,
                        onBlur: C
                    }, o.createElement("div", {
                        className: s()(h.scrollWrap, !this.props.noMomentumBasedScroll && h.momentumBased),
                        style: {
                            overflowY: void 0 !== y ? "scroll" : "auto",
                            maxHeight: g
                        },
                        onScrollCapture: this._handleScroll,
                        ref: this._handleScrollWrapRef
                    }, o.createElement(v, {
                        className: h.menuBox
                    }, d)))), o.createElement(a.Slot, {
                        reference: this._handleSlot
                    })))
                }
                update(e) {
                    e ? this._resizeForced() : this._resize()
                }
            }

            function v(e) {
                const t = (0, i.ensureNotNull)((0, o.useContext)(p.SubmenuContext)),
                    n = o.useRef(null);
                return o.createElement("div", {
                    ref: n,
                    className: e.className,
                    onMouseOver: function(e) {
                        if (!(null !== t.current && e.target instanceof Node && (o = e.target, null === (r = n.current) || void 0 === r ? void 0 : r.contains(o)))) return;
                        var o, r;
                        t.isSubmenuNode(e.target) || t.setCurrent(null)
                    },
                    "data-name": "menu-inner"
                }, e.children)
            }
            g.contextType = p.SubmenuContext
        },
        634993: (e, t, n) => {
            "use strict";
            n.d(t, {
                DEFAULT_POPUP_MENU_ITEM_THEME: () => a,
                PopupMenuItem: () => u
            });
            var o = n(50959),
                r = n(497754),
                s = n(224743),
                i = n(345848),
                l = n(8626),
                c = n(655498);
            const a = c;

            function d(e) {
                e.stopPropagation()
            }

            function u(e) {
                const {
                    id: t,
                    role: n,
                    "aria-label": a,
                    "aria-selected": u,
                    "aria-checked": h,
                    className: p,
                    title: f,
                    labelRowClassName: m,
                    labelClassName: E,
                    shortcut: g,
                    forceShowShortcuts: v,
                    icon: S,
                    isActive: T,
                    isDisabled: D,
                    isHovered: _,
                    appearAsDisabled: C,
                    label: y,
                    link: b,
                    showToolboxOnHover: N,
                    target: M,
                    rel: I,
                    toolbox: O,
                    reference: R,
                    onMouseOut: w,
                    onMouseOver: x,
                    onKeyDown: L,
                    suppressToolboxClick: P = !0,
                    theme: k = c,
                    tabIndex: A,
                    tagName: F,
                    renderComponent: W
                } = e, z = (0, l.filterDataProps)(e), B = (0, o.useRef)(null), H = (0, o.useMemo)((() => function(e) {
                    function t(t) {
                        const {
                            reference: n,
                            ...r
                        } = t, s = null != e ? e : r.href ? "a" : "div", i = "a" === s ? r : function(e) {
                            const {
                                download: t,
                                href: n,
                                hrefLang: o,
                                media: r,
                                ping: s,
                                rel: i,
                                target: l,
                                type: c,
                                referrerPolicy: a,
                                ...d
                            } = e;
                            return d
                        }(r);
                        return o.createElement(s, { ...i,
                            ref: n
                        })
                    }
                    return t.displayName = `DefaultComponent(${e})`, t
                }(F)), [F]), U = null != W ? W : H;
                return o.createElement(U, { ...z,
                    id: t,
                    role: n,
                    "aria-label": a,
                    "aria-selected": u,
                    "aria-checked": h,
                    className: r(p, k.item, S && k.withIcon, {
                        [k.isActive]: T,
                        [k.isDisabled]: D || C,
                        [k.hovered]: _
                    }),
                    title: f,
                    href: b,
                    target: M,
                    rel: I,
                    reference: function(e) {
                        B.current = e, "function" == typeof R && R(e);
                        "object" == typeof R && (R.current = e)
                    },
                    onClick: function(t) {
                        const {
                            dontClosePopup: n,
                            onClick: o,
                            onClickArg: r,
                            trackEventObject: l
                        } = e;
                        if (D) return;
                        l && (0, i.trackEvent)(l.category, l.event, l.label);
                        o && o(r, t);
                        n || (0, s.globalCloseMenu)()
                    },
                    onContextMenu: function(t) {
                        const {
                            trackEventObject: n,
                            trackRightClick: o
                        } = e;
                        n && o && (0, i.trackEvent)(n.category, n.event, `${n.label}_rightClick`)
                    },
                    onMouseUp: function(t) {
                        const {
                            trackEventObject: n,
                            trackMouseWheelClick: o
                        } = e;
                        if (1 === t.button && b && n) {
                            let e = n.label;
                            o && (e += "_mouseWheelClick"), (0, i.trackEvent)(n.category, n.event, e)
                        }
                    },
                    onMouseOver: x,
                    onMouseOut: w,
                    onKeyDown: L,
                    tabIndex: A
                }, void 0 !== S && o.createElement("span", {
                    className: k.icon,
                    dangerouslySetInnerHTML: {
                        __html: S
                    }
                }), o.createElement("span", {
                    className: r(k.labelRow, m)
                }, o.createElement("span", {
                    className: r(k.label, E)
                }, y)), (void 0 !== g || v) && o.createElement("span", {
                    className: k.shortcut
                }, (Y = g) && Y.split("+").join(" + ")), void 0 !== O && o.createElement("span", {
                    onClick: P ? d : void 0,
                    className: r(k.toolbox, {
                        [k.showOnHover]: N
                    })
                }, O));
                var Y
            }
        },
        320116: (e, t, n) => {
            "use strict";
            n.d(t, {
                CloseDelegateContext: () => s
            });
            var o = n(50959),
                r = n(224743);
            const s = o.createContext(r.globalCloseDelegate)
        },
        45968: (e, t, n) => {
            "use strict";
            n.d(t, {
                PopupMenu: () => d
            });
            var o = n(50959),
                r = n(500962),
                s = n(162942),
                i = n(707533),
                l = n(175071),
                c = n(320116),
                a = n(951292);

            function d(e) {
                const {
                    controller: t,
                    children: n,
                    isOpened: d,
                    closeOnClickOutside: u = !0,
                    doNotCloseOn: h,
                    onClickOutside: p,
                    onClose: f,
                    onKeyboardClose: m,
                    "data-name": E = "popup-menu-container",
                    ...g
                } = e, v = (0, o.useContext)(c.CloseDelegateContext), S = (0, a.useOutsideEvent)({
                    handler: function(e) {
                        p && p(e);
                        if (!u) return;
                        const t = (0, s.default)(h) ? h() : h;
                        if (t && e.target instanceof Node) {
                            const n = r.findDOMNode(t);
                            if (n instanceof Node && n.contains(e.target)) return
                        }
                        f()
                    },
                    mouseDown: !0,
                    touchStart: !0
                });
                return d ? o.createElement(i.Portal, {
                    top: "0",
                    left: "0",
                    right: "0",
                    bottom: "0",
                    pointerEvents: "none"
                }, o.createElement("span", {
                    ref: S,
                    style: {
                        pointerEvents: "auto"
                    }
                }, o.createElement(l.Menu, { ...g,
                    onClose: f,
                    onKeyboardClose: m,
                    onScroll: function(t) {
                        const {
                            onScroll: n
                        } = e
                        ;
                        n && n(t)
                    },
                    customCloseDelegate: v,
                    ref: t,
                    "data-name": E
                }, n))) : null
            }
        },
        787684: (e, t, n) => {
            "use strict";
            n.d(t, {
                SubmenuContext: () => r,
                SubmenuHandler: () => s
            });
            var o = n(50959);
            const r = o.createContext(null);

            function s(e) {
                const [t, n] = (0, o.useState)(null), s = (0, o.useRef)(null), i = (0, o.useRef)(new Map);
                return (0, o.useEffect)((() => () => {
                    null !== s.current && clearTimeout(s.current)
                }), []), o.createElement(r.Provider, {
                    value: {
                        current: t,
                        setCurrent: function(e) {
                            null !== s.current && (clearTimeout(s.current), s.current = null);
                            null === t ? n(e) : s.current = setTimeout((() => {
                                s.current = null, n(e)
                            }), 100)
                        },
                        registerSubmenu: function(e, t) {
                            return i.current.set(e, t), () => {
                                i.current.delete(e)
                            }
                        },
                        isSubmenuNode: function(e) {
                            return Array.from(i.current.values()).some((t => t(e)))
                        }
                    }
                }, e.children)
            }
        },
        17049: e => {
            e.exports = {
                button: "button-reABrhVR",
                hover: "hover-reABrhVR",
                arrow: "arrow-reABrhVR",
                arrowWrap: "arrowWrap-reABrhVR",
                isOpened: "isOpened-reABrhVR"
            }
        },
        898930: (e, t, n) => {
            "use strict";
            n.d(t, {
                VerticalAttachEdge: () => o,
                HorizontalAttachEdge: () => r,
                VerticalDropDirection: () => s,
                HorizontalDropDirection: () => i,
                getPopupPositioner: () => a
            });
            var o, r, s, i, l = n(650151);
            ! function(e) {
                e[e.Top = 0] = "Top", e[e.Bottom = 1] = "Bottom"
            }(o || (o = {})),
            function(e) {
                e[e.Left = 0] = "Left", e[e.Right = 1] = "Right"
            }(r || (r = {})),
            function(e) {
                e[e.FromTopToBottom = 0] = "FromTopToBottom", e[e.FromBottomToTop = 1] = "FromBottomToTop"
            }(s || (s = {})),
            function(e) {
                e[e.FromLeftToRight = 0] = "FromLeftToRight", e[e.FromRightToLeft = 1] = "FromRightToLeft"
            }(i || (i = {}));
            const c = {
                verticalAttachEdge: o.Bottom,
                horizontalAttachEdge: r.Left,
                verticalDropDirection: s.FromTopToBottom,
                horizontalDropDirection: i.FromLeftToRight,
                verticalMargin: 0,
                horizontalMargin: 0,
                matchButtonAndListboxWidths: !1
            };

            function a(e, t) {
                return (n, a) => {
                    const d = (0, l.ensureNotNull)(e).getBoundingClientRect(),
                        {
                            verticalAttachEdge: u = c.verticalAttachEdge,
                            verticalDropDirection: h = c.verticalDropDirection,
                            horizontalAttachEdge: p = c.horizontalAttachEdge,
                            horizontalDropDirection: f = c.horizontalDropDirection,
                            horizontalMargin: m = c.horizontalMargin,
                            verticalMargin: E = c.verticalMargin,
                            matchButtonAndListboxWidths: g = c.matchButtonAndListboxWidths
                        } = t,
                        v = u === o.Top ? -1 * E : E,
                        S = p === r.Right ? d.right : d.left,
                        T = u === o.Top ? d.top : d.bottom,
                        D = {
                            x: S - (f === i.FromRightToLeft ? n : 0) + m,
                            y: T - (h === s.FromBottomToTop ? a : 0) + v
                        };
                    return g && (D.overrideWidth = d.width), D
                }
            }
        },
        575296: (e, t, n) => {
            "use strict";
            n.d(t, {
                DEFAULT_TOOL_WIDGET_MENU_THEME: () => f,
                ToolWidgetMenu: () => m
            });
            var o = n(50959),
                r = n(497754),
                s = n(591800),
                i = n(45968),
                l = n(416293),
                c = n(8626),
                a = n(332585),
                d = n(762852),
                u = n(898930),
                h = n(18182),
                p = n(17049);
            const f = p;
            class m extends o.PureComponent {
                constructor(e) {
                    super(e), this._wrapperRef = null, this._controller = o.createRef(), this._handleWrapperRef = e => {
                            this._wrapperRef = e, this.props.reference && this.props.reference(e)
                        }, this._handleClick = e => {
                            e.target instanceof Node && e.currentTarget.contains(e.target) && (this._handleToggleDropdown(), this.props.onClick && this.props.onClick(e, !this.state.isOpened))
                        }, this._handleToggleDropdown = e => {
                            const {
                                onClose: t,
                                onOpen: n
                            } = this.props, {
                                isOpened: o
                            } = this.state, r = "boolean" == typeof e ? e : !o;
                            this.setState({
                                isOpened: r
                            }), r && n && n(), !r && t && t()
                        }, this._handleClose = () => {
                            this.close()
                        },
                        this._handleKeyDown = e => {
                            27 === (0, s.hashFromEvent)(e) && this.state.isOpened && this.props.closeOnEsc && (e.preventDefault(), e.stopPropagation(), this._handleToggleDropdown())
                        }, this.state = {
                            isOpened: !1
                        }
                }
                render() {
                    const {
                        id: e,
                        arrow: t,
                        content: n,
                        isDisabled: s,
                        isDrawer: i,
                        isShowTooltip: a,
                        title: d,
                        className: u,
                        hotKey: p,
                        theme: f,
                        drawerBreakpoint: m,
                        tabIndex: E
                    } = this.props, {
                        isOpened: g
                    } = this.state, v = r(u, f.button, {
                        "apply-common-tooltip": a || !s,
                        [f.isDisabled]: s,
                        [f.isOpened]: g
                    });
                    return o.createElement("div", {
                        id: e,
                        className: v,
                        onClick: s ? void 0 : this._handleClick,
                        title: d,
                        "data-tooltip-hotkey": p,
                        ref: this._handleWrapperRef,
                        "data-role": "button",
                        tabIndex: E,
                        onKeyDown: this._handleKeyDown,
                        ...(0, c.filterDataProps)(this.props)
                    }, n, t && o.createElement("div", {
                        className: f.arrow
                    }, o.createElement("div", {
                        className: f.arrowWrap
                    }, o.createElement(l.ToolWidgetCaret, {
                        dropped: g
                    }))), this.state.isOpened && (m ? o.createElement(h.MatchMedia, {
                        rule: m
                    }, (e => this._renderContent(e))) : this._renderContent(i)))
                }
                close() {
                    this._handleToggleDropdown(!1)
                }
                update() {
                    null !== this._controller.current && this._controller.current.update()
                }
                _renderContent(e) {
                    const {
                        menuDataName: t,
                        minWidth: n,
                        menuClassName: r,
                        maxHeight: s,
                        drawerPosition: l = "Bottom",
                        children: c
                    } = this.props, {
                        isOpened: h
                    } = this.state, p = {
                        horizontalMargin: this.props.horizontalMargin || 0,
                        verticalMargin: this.props.verticalMargin || 2,
                        verticalAttachEdge: this.props.verticalAttachEdge,
                        horizontalAttachEdge: this.props.horizontalAttachEdge,
                        verticalDropDirection: this.props.verticalDropDirection,
                        horizontalDropDirection: this.props.horizontalDropDirection,
                        matchButtonAndListboxWidths: this.props.matchButtonAndListboxWidths
                    }, f = Boolean(h && e && l), m = function(e) {
                        return "function" == typeof e
                    }(c) ? c({
                        isDrawer: f
                    }) : c;
                    return f ? o.createElement(a.DrawerManager, null, o.createElement(d.Drawer, {
                        onClose: this._handleClose,
                        position: l,
                        "data-name": t
                    }, m)) : o.createElement(i.PopupMenu, {
                        controller: this._controller,
                        closeOnClickOutside: this.props.closeOnClickOutside,
                        doNotCloseOn: this,
                        isOpened: h,
                        minWidth: n,
                        onClose: this._handleClose,
                        position: (0, u.getPopupPositioner)(this._wrapperRef, p),
                        className: r,
                        maxHeight: s,
                        "data-name": t
                    }, m)
                }
            }
            m.defaultProps = {
                arrow: !0,
                closeOnClickOutside: !0,
                theme: p
            }
        },
        133055: e => {
            e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" fill="none"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M17.086 6.207a2 2 0 0 1 2.828 0l1.879 1.879a2 2 0 0 1 0 2.828l-.94.94-9 9-1 1-.146.146H6v-4.707l.146-.146 1-1 9-9 .94-.94zm2.121.707a1 1 0 0 0-1.414 0l-.586.586 1.647 1.646 1.646 1.647.586-.586a1 1 0 0 0 0-1.414l-1.879-1.879zm.586 4.586L18.5 10.207 10.207 18.5l1.293 1.293 8.293-8.293zm-9 9l-1.647-1.646L7.5 17.207l-.5.5V21h3.293l.5-.5zm-2.586-4L9.5 17.793 17.793 9.5 16.5 8.207 8.207 16.5z"/></svg>'
        },
        569533: e => {
            e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="none"><path stroke="currentColor" d="M8 5l3.5 3.5L8 12"/></svg>'
        }
    }
]);